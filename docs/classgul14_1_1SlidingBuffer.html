<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++14: gul14::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul14.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++14
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul14.html">gul14</a></li><li class="navelem"><a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgul14_1_1SlidingBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gul14::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SlidingBuffer__h.html">gul14/SlidingBuffer.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ElementT, std::size_t fixed_capacity = 0u, typename Container = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt;<br />
class gul14::SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt;</h3>

<p>A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the back. </p>
<p>A <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> is a flat array containing zero to <a class="el" href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669" title="Return the maximum possible number of elements in the container.">capacity()</a> elements of an arbitrary type. The capacity can either be specified at compile time via a template parameter or at runtime via <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a>. In the former case, the internal buffer is embedded in the object (std::array), in the latter case it is dynamically allocated (std::vector).</p>
<p>The <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> shares many characteristics with traditional ring buffers: It has a fixed maximum size and new elements are added with <a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> or <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a>. If this is done when the buffer is <a class="el" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b" title="Return true if the buffer is completely filled with elements.">filled()</a> to capacity, an element automatically drops out at the other end of the sliding window:</p>
<div class="fragment"><div class="line">SlidingBuffer&lt;int, 2&gt; buf; <span class="comment">// Create a buffer with up to 2 entries</span></div>
<div class="line"> </div>
<div class="line">buf.push_back(1);</div>
<div class="line">buf.push_back(2);</div>
<div class="line">buf.push_back(3);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; buf[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; buf[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="comment">// prints &quot;2, 3&quot;</span></div>
<div class="line"> </div>
<div class="line">buf.push_front(1);</div>
<div class="line">std::cout &lt;&lt; buf[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; buf[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="comment">// prints &quot;1, 2&quot;</span></div>
</div><!-- fragment --><p>This buffer is not intended for producer-consumer problems. If the elements access is atomic it is thread-safe though. All auxiliary functions that mutate the data are not thread safe.</p>
<p>Differing from arrays this buffer will start empty (with a size of zero). Once the buffer has grown to its designated size (i.e. capacity), its <a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a> only changes if <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ee0f513eeb009d0cf4f1287bb99b034" title="Empty the buffer.">clear()</a>, <a class="el" href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86" title="Remove the first element from the buffer.">pop_front()</a>, or <a class="el" href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c" title="Remove the last element from the buffer.">pop_back()</a> are used.</p>
<p>A typical application would be to analyze an incoming stream of elements in a finite impulse response filter.</p>
<p>This container uses an accompanying iterator class called <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html" title="Iterator of the SlidingBuffer container.">SlidingBufferIterator</a>. See <a class="el" href="classgul14_1_1SlidingBufferExposed.html" title="A variant of SlidingBuffer that exposes the underlying container through its iterator interface.">SlidingBufferExposed</a> for a variant with a different (more performant) iterator interface.</p>
<p>Iterator invalidation is specified at <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html" title="Iterator of the SlidingBuffer container.">SlidingBufferIterator</a>.</p>
<div class="fragment"><div class="line">Member types:</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a>                  Type of the elements</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a>              Type of the underlying container (i.e. std::array&lt;value_type, ..&gt;)</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>                   Unsigned integer type (usually std::size_t)</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a778a6ddba858e69eb43944620f18ac52">difference_type</a>             Signed integer type (usually std::ptrdiff_t)</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a>                   <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a>&amp;</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a>             <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> <span class="keyword">const</span>&amp;</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#af2747d48bae3f203eba23f3bffece7ca">pointer</a>                     <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a>*</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a71b864862a2cbb466b8d321e24db2fbb">const_pointer</a>               <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> <span class="keyword">const</span>*</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a>                    SlidingBufferIterator</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a>              SlidingBufferIterator <span class="keyword">const</span></div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a>            SlidingBufferIterator</div>
<div class="line">  <a class="code" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a>      SlidingBufferIterator <span class="keyword">const</span></div>
<div class="line"> </div>
<div class="line">Member functions:</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a758cece56fdc55174a54419e973091b1">SlidingBuffer</a>     Constructor</div>
<div class="line">  Element access:</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f">push_back</a>         Insert an element <a class="code" href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">at</a> the <a class="code" href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04">back</a> of the buffer</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0">push_front</a>        Insert an element <a class="code" href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">at</a> the <a class="code" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57">front</a> of the buffer</div>
<div class="line">    <span class="keyword">operator</span>[]        Access element by index, unchecked</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">at</a>                Access element by index with bounds checking</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57">front</a>             Access the foremost element (i.e. [0])</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04">back</a>              Access the last element (i.e. [<a class="code" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">size</a>() - 1])</div>
<div class="line">  Iterators:</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926">begin</a>, <a class="code" href="classgul14_1_1SlidingBuffer.html#a29083d647150699f543cdf2f093536eb">cbegin</a>     Return an <a class="code" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> to the first element of the container</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463">end</a>, <a class="code" href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe">cend</a>         Return an <a class="code" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> to the element following the last element of the container</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a708896fdb522f58ab5f16f16936bcd4f">rbegin</a>, <a class="code" href="classgul14_1_1SlidingBuffer.html#ae924d5a9696cff90d66c2388f2b8a546">crbegin</a>   Return an <a class="code" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> to the first element of the reversed container</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#ad235ba18dd22c5e094e62a9a5968622c">rend</a>, <a class="code" href="classgul14_1_1SlidingBuffer.html#a6173da082380357f6cbe1af6bc44dde6">crend</a>       Return an <a class="code" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> to the element following the last element of the reversed container</div>
<div class="line">  Capacity:</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">size</a>              Return number of used elements</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669">capacity</a>          Return <a class="code" href="group__statistics__h.html#ga78b824c80d48bff9d5ec5c42950dc279">maximum</a> number of elements</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b">filled</a>            Check whether the buffer is completely <a class="code" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b">filled</a></div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a935b8e8adcf24a828cefcf897f774d65">empty</a>             Check whether the buffer is <a class="code" href="classgul14_1_1SlidingBuffer.html#a935b8e8adcf24a828cefcf897f774d65">empty</a></div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3">resize</a>            Change the <a class="code" href="group__statistics__h.html#ga78b824c80d48bff9d5ec5c42950dc279">maximum</a> number of elements (only if fixed_size==0)</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a5290ddbfe6ef4a30cf066c5ec2af937b">reserve</a>           Change the <a class="code" href="group__statistics__h.html#ga78b824c80d48bff9d5ec5c42950dc279">maximum</a> number of elements (only if fixed_size==0)</div>
<div class="line">  Modifiers:</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a9ee0f513eeb009d0cf4f1287bb99b034">clear</a>             Empty the buffer</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c">pop_back</a>          Drop the last element</div>
<div class="line">    <a class="code" href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86">pop_front</a>         Drop the foremost element</div>
<div class="line"> </div>
<div class="line">Non-member functions:</div>
<div class="line">  operator&lt;&lt;          Dump the raw data of the buffer to an ostream</div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a0695ad356f048abb6f4f4a9efce293b0"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0">gul14::SlidingBuffer::push_front</a></div><div class="ttdeci">auto push_front(const value_type &amp;in) -&gt; void</div><div class="ttdoc">Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:344</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a1132f5141a579296c1db4bc7de953df2"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">gul14::SlidingBuffer::size_type</a></div><div class="ttdeci">typename Container::size_type size_type</div><div class="ttdoc">Unsigned integer type (usually std::size_t)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:190</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a1c3c5e7535ef37b0b22a9e83e167380b"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b">gul14::SlidingBuffer::filled</a></div><div class="ttdeci">auto filled() const noexcept -&gt; bool</div><div class="ttdoc">Return true if the buffer is completely filled with elements.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:514</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a29083d647150699f543cdf2f093536eb"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a29083d647150699f543cdf2f093536eb">gul14::SlidingBuffer::cbegin</a></div><div class="ttdeci">auto cbegin() const noexcept -&gt; const_iterator</div><div class="ttdoc">Return a read-only iterator to the first element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:901</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a3139cfe59efb599f28326c38c22ab124"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">gul14::SlidingBuffer::size</a></div><div class="ttdeci">auto size() const noexcept -&gt; size_type</div><div class="ttdoc">Return the number of elements in the container, i.e.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:483</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a3e17c7b0c76993f335c5a6bb30e18908"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">gul14::SlidingBuffer::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdoc">Iterator to a const element in reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:208</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a40e6256ce0debc120c6b988ed25d52fe"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe">gul14::SlidingBuffer::cend</a></div><div class="ttdeci">auto cend() const noexcept -&gt; const_iterator</div><div class="ttdoc">Return a read-only iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:923</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a4d9c21ecd931942bb4c2f1b3ffe58f75"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">gul14::SlidingBuffer::at</a></div><div class="ttdeci">auto at(const size_type idx) noexcept(false) -&gt; reference</div><div class="ttdoc">Access an element in the buffer by index with bounds checking.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:409</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a50fda19308fc237eedf39b8a83460a86"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86">gul14::SlidingBuffer::pop_front</a></div><div class="ttdeci">auto pop_front() -&gt; void</div><div class="ttdoc">Remove the first element from the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:287</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a5290ddbfe6ef4a30cf066c5ec2af937b"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a5290ddbfe6ef4a30cf066c5ec2af937b">gul14::SlidingBuffer::reserve</a></div><div class="ttdeci">auto reserve(size_type size, ShrinkBehavior shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</div><div class="ttdoc">Resize the container (identical to resize()).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:566</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a5bba5feb1a0b8a47be93612e4e8960e2"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">gul14::SlidingBuffer::const_iterator</a></div><div class="ttdeci">SlidingBufferIterator&lt; SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; const  * &gt; const_iterator</div><div class="ttdoc">Iterator to a const element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:204</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a6173da082380357f6cbe1af6bc44dde6"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a6173da082380357f6cbe1af6bc44dde6">gul14::SlidingBuffer::crend</a></div><div class="ttdeci">auto crend() const noexcept -&gt; const_reverse_iterator</div><div class="ttdoc">Return a read-only iterator to the element following the last element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:935</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a61d4fae557fab57f3495f4ef0fc42bac"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">gul14::SlidingBuffer::container_type</a></div><div class="ttdeci">Container container_type</div><div class="ttdoc">Type of the underlying container (e.g. std::array&lt;value_type, ..&gt;)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:186</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a656b21097b312844532202f26b7d0622"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">gul14::SlidingBuffer::const_reference</a></div><div class="ttdeci">typename Container::const_reference const_reference</div><div class="ttdoc">Reference to a constant element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:196</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a6dee2dbecac406a8fb2c6d9e82369463"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463">gul14::SlidingBuffer::end</a></div><div class="ttdeci">auto end() noexcept -&gt; iterator</div><div class="ttdoc">Return an iterator to the element following the last element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:873</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a708896fdb522f58ab5f16f16936bcd4f"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a708896fdb522f58ab5f16f16936bcd4f">gul14::SlidingBuffer::rbegin</a></div><div class="ttdeci">auto rbegin() noexcept -&gt; reverse_iterator</div><div class="ttdoc">Return an iterator to the first element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:862</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a71b864862a2cbb466b8d321e24db2fbb"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a71b864862a2cbb466b8d321e24db2fbb">gul14::SlidingBuffer::const_pointer</a></div><div class="ttdeci">typename Container::const_pointer const_pointer</div><div class="ttdoc">Pointer to a constant element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:200</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a758cece56fdc55174a54419e973091b1"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a758cece56fdc55174a54419e973091b1">gul14::SlidingBuffer::SlidingBuffer</a></div><div class="ttdeci">SlidingBuffer()=default</div><div class="ttdoc">Construct an empty sliding buffer.</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a778a6ddba858e69eb43944620f18ac52"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a778a6ddba858e69eb43944620f18ac52">gul14::SlidingBuffer::difference_type</a></div><div class="ttdeci">typename Container::difference_type difference_type</div><div class="ttdoc">Signed integer type (usually std::ptrdiff_t)</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:192</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a80dee89411602a01b7dfa431d7d7b462"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">gul14::SlidingBuffer::reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; iterator &gt; reverse_iterator</div><div class="ttdoc">Iterator to an element in reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:206</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a8a334331c9384a1ce7ffb37122839c57"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57">gul14::SlidingBuffer::front</a></div><div class="ttdeci">auto front() noexcept -&gt; reference</div><div class="ttdoc">Return the foremost element (the one with index 0).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:438</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a935b8e8adcf24a828cefcf897f774d65"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a935b8e8adcf24a828cefcf897f774d65">gul14::SlidingBuffer::empty</a></div><div class="ttdeci">auto empty() const noexcept -&gt; bool</div><div class="ttdoc">Check if the buffer contains no elements, i.e.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:578</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a9ba888ff71b5ae3ab0f97bdb1ff4a424"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">gul14::SlidingBuffer::value_type</a></div><div class="ttdeci">ElementT value_type</div><div class="ttdoc">Type of the elements in the underlying container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:188</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_a9ee0f513eeb009d0cf4f1287bb99b034"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#a9ee0f513eeb009d0cf4f1287bb99b034">gul14::SlidingBuffer::clear</a></div><div class="ttdeci">auto clear() -&gt; void</div><div class="ttdoc">Empty the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:526</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_aa2bb25710aab15cbd906f775e91772a3"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3">gul14::SlidingBuffer::resize</a></div><div class="ttdeci">auto resize(size_type new_capacity, ShrinkBehavior shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</div><div class="ttdoc">Resize the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:555</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_abf2d22595a4e33b8c08ed0add642e540"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">gul14::SlidingBuffer::iterator</a></div><div class="ttdeci">SlidingBufferIterator&lt; SlidingBuffer&lt; ElementT, fixed_capacity, Container &gt; * &gt; iterator</div><div class="ttdoc">Iterator to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:202</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_ad235ba18dd22c5e094e62a9a5968622c"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#ad235ba18dd22c5e094e62a9a5968622c">gul14::SlidingBuffer::rend</a></div><div class="ttdeci">auto rend() noexcept -&gt; reverse_iterator</div><div class="ttdoc">Return an iterator to the element following the last element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:891</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_addf46f20df776f4770101fdc587ed669"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669">gul14::SlidingBuffer::capacity</a></div><div class="ttdeci">constexpr auto capacity() const noexcept -&gt; size_type</div><div class="ttdoc">Return the maximum possible number of elements in the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:501</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_ae3aa68a4157c6d92108ecbec243f35df"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">gul14::SlidingBuffer::reference</a></div><div class="ttdeci">typename Container::reference reference</div><div class="ttdoc">Reference to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:194</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_ae8c4ed682cf26ec3d281b258c941e11c"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c">gul14::SlidingBuffer::pop_back</a></div><div class="ttdeci">auto pop_back() -&gt; void</div><div class="ttdoc">Remove the last element from the buffer.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:270</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_ae924d5a9696cff90d66c2388f2b8a546"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#ae924d5a9696cff90d66c2388f2b8a546">gul14::SlidingBuffer::crbegin</a></div><div class="ttdeci">auto crbegin() const noexcept -&gt; const_reverse_iterator</div><div class="ttdoc">Return a read-only iterator to the first element of the reversed container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:911</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_aeffd5a70377ebdc5cecbfc217e94a926"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926">gul14::SlidingBuffer::begin</a></div><div class="ttdeci">auto begin() noexcept -&gt; iterator</div><div class="ttdoc">Return an iterator to the first element of the container.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:846</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_af2747d48bae3f203eba23f3bffece7ca"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#af2747d48bae3f203eba23f3bffece7ca">gul14::SlidingBuffer::pointer</a></div><div class="ttdeci">typename Container::pointer pointer</div><div class="ttdoc">Pointer to an element.</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:198</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_af33f9079f10e529b2756d209368a4d04"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04">gul14::SlidingBuffer::back</a></div><div class="ttdeci">auto back() noexcept -&gt; reference</div><div class="ttdoc">Return the backmost element (the one with the highest valid index).</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:457</div></div>
<div class="ttc" id="aclassgul14_1_1SlidingBuffer_html_afd5dc40066c6e511464d51b2301b203f"><div class="ttname"><a href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f">gul14::SlidingBuffer::push_back</a></div><div class="ttdeci">auto push_back(const value_type &amp;in) -&gt; void</div><div class="ttdoc">Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...</div><div class="ttdef"><b>Definition:</b> SlidingBuffer.h:306</div></div>
<div class="ttc" id="agroup__statistics__h_html_ga78b824c80d48bff9d5ec5c42950dc279"><div class="ttname"><a href="group__statistics__h.html#ga78b824c80d48bff9d5ec5c42950dc279">gul14::maximum</a></div><div class="ttdeci">auto maximum(ContainerT const &amp;container, Accessor accessor=ElementAccessor&lt; ElementT &gt;()) -&gt; DataT</div><div class="ttdoc">Return the maximum element value in a container.</div><div class="ttdef"><b>Definition:</b> statistics.h:314</div></div>
</div><!-- fragment --><p>The sliding buffer can be instantiated in two slightly different versions:</p><ul>
<li>If the size is known at compile time, it can be specified as the <b><code>fixed_capacity</code></b> template parameter. The elements are stored within the sliding buffer as in a std::array.</li>
<li>If a flexible capacity is desired, <b><code>fixed_capacity</code></b> can be omitted. It defaults to zero, and space for elements can subsequently be allocated dynamically as in a std::vector. You need to use a constructor that sets a certain capacity or set the capacity afterwards with <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a>. As long as the capacity is zero, the buffer is unusable and most operations result in undefined behavior.</li>
</ul>
<p><b><code>ElementT</code></b> must be default constructible.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>Type of elements in the buffer </td></tr>
    <tr><td class="paramname">fixed_capacity</td><td>Maximum number of elements in the buffer (capacity), zero if unspecified/dynamic </td></tr>
    <tr><td class="paramname">Container</td><td>Type of the underlying container, usually not specified </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;<a class="el" href="SlidingBuffer_8h_source.html">SlidingBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator of the <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> container.  <a href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a61d4fae557fab57f3495f4ef0fc42bac"><td class="memItemLeft" align="right" valign="top"><a id="a61d4fae557fab57f3495f4ef0fc42bac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a> = Container</td></tr>
<tr class="memdesc:a61d4fae557fab57f3495f4ef0fc42bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying container (e.g. std::array&lt;value_type, ..&gt;) <br /></td></tr>
<tr class="separator:a61d4fae557fab57f3495f4ef0fc42bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba888ff71b5ae3ab0f97bdb1ff4a424"><td class="memItemLeft" align="right" valign="top"><a id="a9ba888ff71b5ae3ab0f97bdb1ff4a424"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> = ElementT</td></tr>
<tr class="memdesc:a9ba888ff71b5ae3ab0f97bdb1ff4a424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in the underlying container. <br /></td></tr>
<tr class="separator:a9ba888ff71b5ae3ab0f97bdb1ff4a424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1132f5141a579296c1db4bc7de953df2"><td class="memItemLeft" align="right" valign="top"><a id="a1132f5141a579296c1db4bc7de953df2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> = typename Container::size_type</td></tr>
<tr class="memdesc:a1132f5141a579296c1db4bc7de953df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type (usually std::size_t) <br /></td></tr>
<tr class="separator:a1132f5141a579296c1db4bc7de953df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a6ddba858e69eb43944620f18ac52"><td class="memItemLeft" align="right" valign="top"><a id="a778a6ddba858e69eb43944620f18ac52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a778a6ddba858e69eb43944620f18ac52">difference_type</a> = typename Container::difference_type</td></tr>
<tr class="memdesc:a778a6ddba858e69eb43944620f18ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type (usually std::ptrdiff_t) <br /></td></tr>
<tr class="separator:a778a6ddba858e69eb43944620f18ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3aa68a4157c6d92108ecbec243f35df"><td class="memItemLeft" align="right" valign="top"><a id="ae3aa68a4157c6d92108ecbec243f35df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a> = typename Container::reference</td></tr>
<tr class="memdesc:ae3aa68a4157c6d92108ecbec243f35df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to an element. <br /></td></tr>
<tr class="separator:ae3aa68a4157c6d92108ecbec243f35df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656b21097b312844532202f26b7d0622"><td class="memItemLeft" align="right" valign="top"><a id="a656b21097b312844532202f26b7d0622"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a> = typename Container::const_reference</td></tr>
<tr class="memdesc:a656b21097b312844532202f26b7d0622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant element. <br /></td></tr>
<tr class="separator:a656b21097b312844532202f26b7d0622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2747d48bae3f203eba23f3bffece7ca"><td class="memItemLeft" align="right" valign="top"><a id="af2747d48bae3f203eba23f3bffece7ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#af2747d48bae3f203eba23f3bffece7ca">pointer</a> = typename Container::pointer</td></tr>
<tr class="memdesc:af2747d48bae3f203eba23f3bffece7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an element. <br /></td></tr>
<tr class="separator:af2747d48bae3f203eba23f3bffece7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b864862a2cbb466b8d321e24db2fbb"><td class="memItemLeft" align="right" valign="top"><a id="a71b864862a2cbb466b8d321e24db2fbb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a71b864862a2cbb466b8d321e24db2fbb">const_pointer</a> = typename Container::const_pointer</td></tr>
<tr class="memdesc:a71b864862a2cbb466b8d321e24db2fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant element. <br /></td></tr>
<tr class="separator:a71b864862a2cbb466b8d321e24db2fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d22595a4e33b8c08ed0add642e540"><td class="memItemLeft" align="right" valign="top"><a id="abf2d22595a4e33b8c08ed0add642e540"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> = <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt; * &gt;</td></tr>
<tr class="memdesc:abf2d22595a4e33b8c08ed0add642e540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element. <br /></td></tr>
<tr class="separator:abf2d22595a4e33b8c08ed0add642e540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bba5feb1a0b8a47be93612e4e8960e2"><td class="memItemLeft" align="right" valign="top"><a id="a5bba5feb1a0b8a47be93612e4e8960e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a> = <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt; const  * &gt;</td></tr>
<tr class="memdesc:a5bba5feb1a0b8a47be93612e4e8960e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element. <br /></td></tr>
<tr class="separator:a5bba5feb1a0b8a47be93612e4e8960e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dee89411602a01b7dfa431d7d7b462"><td class="memItemLeft" align="right" valign="top"><a id="a80dee89411602a01b7dfa431d7d7b462"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a> &gt;</td></tr>
<tr class="memdesc:a80dee89411602a01b7dfa431d7d7b462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element in reversed container. <br /></td></tr>
<tr class="separator:a80dee89411602a01b7dfa431d7d7b462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e17c7b0c76993f335c5a6bb30e18908"><td class="memItemLeft" align="right" valign="top"><a id="a3e17c7b0c76993f335c5a6bb30e18908"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a3e17c7b0c76993f335c5a6bb30e18908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element in reversed container. <br /></td></tr>
<tr class="separator:a3e17c7b0c76993f335c5a6bb30e18908"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a758cece56fdc55174a54419e973091b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a758cece56fdc55174a54419e973091b1">SlidingBuffer</a> ()=default</td></tr>
<tr class="memdesc:a758cece56fdc55174a54419e973091b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty sliding buffer.  <a href="classgul14_1_1SlidingBuffer.html#a758cece56fdc55174a54419e973091b1">More...</a><br /></td></tr>
<tr class="separator:a758cece56fdc55174a54419e973091b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9fde177de64faeecdf61fa6d6aaf83"><td class="memItemLeft" align="right" valign="top"><a id="a4c9fde177de64faeecdf61fa6d6aaf83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a4c9fde177de64faeecdf61fa6d6aaf83">SlidingBuffer</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> const &amp;)=default</td></tr>
<tr class="memdesc:a4c9fde177de64faeecdf61fa6d6aaf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:a4c9fde177de64faeecdf61fa6d6aaf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2bdce8ae32e54fbd8a3e7814de3ce3"><td class="memItemLeft" align="right" valign="top"><a id="a4a2bdce8ae32e54fbd8a3e7814de3ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a4a2bdce8ae32e54fbd8a3e7814de3ce3">SlidingBuffer</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&amp;) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a> &gt;::value)=default</td></tr>
<tr class="memdesc:a4a2bdce8ae32e54fbd8a3e7814de3ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:a4a2bdce8ae32e54fbd8a3e7814de3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae462d11711751396d4d7b4240de25327"><td class="memItemLeft" align="right" valign="top"><a id="ae462d11711751396d4d7b4240de25327"></a>
<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae462d11711751396d4d7b4240de25327">operator=</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> const &amp;)=default</td></tr>
<tr class="memdesc:ae462d11711751396d4d7b4240de25327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator. <br /></td></tr>
<tr class="separator:ae462d11711751396d4d7b4240de25327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64323d5f059278047004d6f77769de1"><td class="memItemLeft" align="right" valign="top"><a id="ae64323d5f059278047004d6f77769de1"></a>
<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae64323d5f059278047004d6f77769de1">operator=</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> &amp;&amp;) noexcept(std::is_nothrow_move_assignable&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a> &gt;::value)=default</td></tr>
<tr class="memdesc:ae64323d5f059278047004d6f77769de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator. <br /></td></tr>
<tr class="separator:ae64323d5f059278047004d6f77769de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d59b6590ec9329166cf1ef85714b4"><td class="memItemLeft" align="right" valign="top"><a id="a304d59b6590ec9329166cf1ef85714b4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a304d59b6590ec9329166cf1ef85714b4">~SlidingBuffer</a> ()=default</td></tr>
<tr class="memdesc:a304d59b6590ec9329166cf1ef85714b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor. <br /></td></tr>
<tr class="separator:a304d59b6590ec9329166cf1ef85714b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e5d070158c684b6a363704d9d4eb7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a92e5d070158c684b6a363704d9d4eb7d">SlidingBuffer</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> count)</td></tr>
<tr class="memdesc:a92e5d070158c684b6a363704d9d4eb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Only available for sliding buffers based on std::vector.  <a href="classgul14_1_1SlidingBuffer.html#a92e5d070158c684b6a363704d9d4eb7d">More...</a><br /></td></tr>
<tr class="separator:a92e5d070158c684b6a363704d9d4eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c4ed682cf26ec3d281b258c941e11c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c">pop_back</a> () -&gt; void</td></tr>
<tr class="memdesc:ae8c4ed682cf26ec3d281b258c941e11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the buffer.  <a href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c">More...</a><br /></td></tr>
<tr class="separator:ae8c4ed682cf26ec3d281b258c941e11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fda19308fc237eedf39b8a83460a86"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86">pop_front</a> () -&gt; void</td></tr>
<tr class="memdesc:a50fda19308fc237eedf39b8a83460a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element from the buffer.  <a href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86">More...</a><br /></td></tr>
<tr class="separator:a50fda19308fc237eedf39b8a83460a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5dc40066c6e511464d51b2301b203f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f">push_back</a> (const <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;in) -&gt; void</td></tr>
<tr class="memdesc:afd5dc40066c6e511464d51b2301b203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element at the end of the buffer; if it is full, an element at the front is dropped to make room.  <a href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f">More...</a><br /></td></tr>
<tr class="separator:afd5dc40066c6e511464d51b2301b203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fb99748ccd3f42dbf068ee517a0033"><td class="memItemLeft" align="right" valign="top"><a id="a61fb99748ccd3f42dbf068ee517a0033"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a61fb99748ccd3f42dbf068ee517a0033">push_back</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;&amp;in) -&gt; void</td></tr>
<tr class="memdesc:a61fb99748ccd3f42dbf068ee517a0033"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a61fb99748ccd3f42dbf068ee517a0033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0695ad356f048abb6f4f4a9efce293b0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0">push_front</a> (const <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;in) -&gt; void</td></tr>
<tr class="memdesc:a0695ad356f048abb6f4f4a9efce293b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element at the front of the buffer; if it is full, an element at the back is dropped to make room.  <a href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0">More...</a><br /></td></tr>
<tr class="separator:a0695ad356f048abb6f4f4a9efce293b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb11c0c64fb18833eaccc106ecbddf9"><td class="memItemLeft" align="right" valign="top"><a id="adeb11c0c64fb18833eaccc106ecbddf9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#adeb11c0c64fb18833eaccc106ecbddf9">push_front</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;&amp;in) -&gt; void</td></tr>
<tr class="memdesc:adeb11c0c64fb18833eaccc106ecbddf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:adeb11c0c64fb18833eaccc106ecbddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babf297b0f253df5dcfa9ad288a1591"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a7babf297b0f253df5dcfa9ad288a1591">operator[]</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> idx) noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a></td></tr>
<tr class="memdesc:a7babf297b0f253df5dcfa9ad288a1591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element in the buffer by index without bounds checking.  <a href="classgul14_1_1SlidingBuffer.html#a7babf297b0f253df5dcfa9ad288a1591">More...</a><br /></td></tr>
<tr class="separator:a7babf297b0f253df5dcfa9ad288a1591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783780e57c65536f938b8819baf3f8d"><td class="memItemLeft" align="right" valign="top"><a id="a3783780e57c65536f938b8819baf3f8d"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a3783780e57c65536f938b8819baf3f8d">operator[]</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> idx) const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a></td></tr>
<tr class="memdesc:a3783780e57c65536f938b8819baf3f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a3783780e57c65536f938b8819baf3f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9c21ecd931942bb4c2f1b3ffe58f75"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">at</a> (const <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> idx) noexcept(false) -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a></td></tr>
<tr class="memdesc:a4d9c21ecd931942bb4c2f1b3ffe58f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element in the buffer by index with bounds checking.  <a href="classgul14_1_1SlidingBuffer.html#a4d9c21ecd931942bb4c2f1b3ffe58f75">More...</a><br /></td></tr>
<tr class="separator:a4d9c21ecd931942bb4c2f1b3ffe58f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae535bbbcc60d3fbb6368cf5a48137261"><td class="memItemLeft" align="right" valign="top"><a id="ae535bbbcc60d3fbb6368cf5a48137261"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae535bbbcc60d3fbb6368cf5a48137261">at</a> (const <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> idx) const noexcept(false) -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a></td></tr>
<tr class="memdesc:ae535bbbcc60d3fbb6368cf5a48137261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ae535bbbcc60d3fbb6368cf5a48137261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a334331c9384a1ce7ffb37122839c57"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57">front</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a></td></tr>
<tr class="memdesc:a8a334331c9384a1ce7ffb37122839c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the foremost element (the one with index 0).  <a href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57">More...</a><br /></td></tr>
<tr class="separator:a8a334331c9384a1ce7ffb37122839c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d428f9fa2214d7dadccfeb12151919"><td class="memItemLeft" align="right" valign="top"><a id="a96d428f9fa2214d7dadccfeb12151919"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a96d428f9fa2214d7dadccfeb12151919">front</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a></td></tr>
<tr class="memdesc:a96d428f9fa2214d7dadccfeb12151919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a96d428f9fa2214d7dadccfeb12151919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33f9079f10e529b2756d209368a4d04"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04">back</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a></td></tr>
<tr class="memdesc:af33f9079f10e529b2756d209368a4d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the backmost element (the one with the highest valid index).  <a href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04">More...</a><br /></td></tr>
<tr class="separator:af33f9079f10e529b2756d209368a4d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae82cb3ef10ef665fea404c4506e1aa"><td class="memItemLeft" align="right" valign="top"><a id="aeae82cb3ef10ef665fea404c4506e1aa"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#aeae82cb3ef10ef665fea404c4506e1aa">back</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a656b21097b312844532202f26b7d0622">const_reference</a></td></tr>
<tr class="memdesc:aeae82cb3ef10ef665fea404c4506e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aeae82cb3ef10ef665fea404c4506e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3139cfe59efb599f28326c38c22ab124"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">size</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a></td></tr>
<tr class="memdesc:a3139cfe59efb599f28326c38c22ab124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the container, i.e.  <a href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">More...</a><br /></td></tr>
<tr class="separator:a3139cfe59efb599f28326c38c22ab124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf46f20df776f4770101fdc587ed669"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669">capacity</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a></td></tr>
<tr class="memdesc:addf46f20df776f4770101fdc587ed669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible number of elements in the container.  <a href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669">More...</a><br /></td></tr>
<tr class="separator:addf46f20df776f4770101fdc587ed669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c5e7535ef37b0b22a9e83e167380b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b">filled</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a1c3c5e7535ef37b0b22a9e83e167380b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the buffer is completely filled with elements.  <a href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b">More...</a><br /></td></tr>
<tr class="separator:a1c3c5e7535ef37b0b22a9e83e167380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee0f513eeb009d0cf4f1287bb99b034"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a9ee0f513eeb009d0cf4f1287bb99b034">clear</a> () -&gt; void</td></tr>
<tr class="memdesc:a9ee0f513eeb009d0cf4f1287bb99b034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the buffer.  <a href="classgul14_1_1SlidingBuffer.html#a9ee0f513eeb009d0cf4f1287bb99b034">More...</a><br /></td></tr>
<tr class="separator:a9ee0f513eeb009d0cf4f1287bb99b034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bb25710aab15cbd906f775e91772a3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3">resize</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> new_capacity, <a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:aa2bb25710aab15cbd906f775e91772a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container.  <a href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3">More...</a><br /></td></tr>
<tr class="separator:aa2bb25710aab15cbd906f775e91772a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5290ddbfe6ef4a30cf066c5ec2af937b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a5290ddbfe6ef4a30cf066c5ec2af937b">reserve</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> <a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124">size</a>, <a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:a5290ddbfe6ef4a30cf066c5ec2af937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the container (identical to <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a>).  <a href="classgul14_1_1SlidingBuffer.html#a5290ddbfe6ef4a30cf066c5ec2af937b">More...</a><br /></td></tr>
<tr class="separator:a5290ddbfe6ef4a30cf066c5ec2af937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b8e8adcf24a828cefcf897f774d65"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a935b8e8adcf24a828cefcf897f774d65">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a935b8e8adcf24a828cefcf897f774d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer contains no elements, i.e.  <a href="classgul14_1_1SlidingBuffer.html#a935b8e8adcf24a828cefcf897f774d65">More...</a><br /></td></tr>
<tr class="separator:a935b8e8adcf24a828cefcf897f774d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06976bd19f36cd1400a70231339954e6"><td class="memItemLeft" align="right" valign="top">auto friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a06976bd19f36cd1400a70231339954e6">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a>, fixed_capacity, <a class="el" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a> &gt; &amp;buffer) -&gt; std::ostream &amp;</td></tr>
<tr class="memdesc:a06976bd19f36cd1400a70231339954e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all buffer elements.  <a href="classgul14_1_1SlidingBuffer.html#a06976bd19f36cd1400a70231339954e6">More...</a><br /></td></tr>
<tr class="separator:a06976bd19f36cd1400a70231339954e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffd5a70377ebdc5cecbfc217e94a926"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926">begin</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a></td></tr>
<tr class="memdesc:aeffd5a70377ebdc5cecbfc217e94a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element of the container.  <a href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926">More...</a><br /></td></tr>
<tr class="separator:aeffd5a70377ebdc5cecbfc217e94a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6379926eef6b4bae74ffff6859816b"><td class="memItemLeft" align="right" valign="top"><a id="aac6379926eef6b4bae74ffff6859816b"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#aac6379926eef6b4bae74ffff6859816b">begin</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a></td></tr>
<tr class="memdesc:aac6379926eef6b4bae74ffff6859816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aac6379926eef6b4bae74ffff6859816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708896fdb522f58ab5f16f16936bcd4f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a708896fdb522f58ab5f16f16936bcd4f">rbegin</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a></td></tr>
<tr class="memdesc:a708896fdb522f58ab5f16f16936bcd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element of the reversed container.  <a href="classgul14_1_1SlidingBuffer.html#a708896fdb522f58ab5f16f16936bcd4f">More...</a><br /></td></tr>
<tr class="separator:a708896fdb522f58ab5f16f16936bcd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dee2dbecac406a8fb2c6d9e82369463"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463">end</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a></td></tr>
<tr class="memdesc:a6dee2dbecac406a8fb2c6d9e82369463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last element of the container.  <a href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463">More...</a><br /></td></tr>
<tr class="separator:a6dee2dbecac406a8fb2c6d9e82369463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f84c4200923ec94fcf003f673b65ad"><td class="memItemLeft" align="right" valign="top"><a id="af4f84c4200923ec94fcf003f673b65ad"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#af4f84c4200923ec94fcf003f673b65ad">end</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a></td></tr>
<tr class="memdesc:af4f84c4200923ec94fcf003f673b65ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af4f84c4200923ec94fcf003f673b65ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad235ba18dd22c5e094e62a9a5968622c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ad235ba18dd22c5e094e62a9a5968622c">rend</a> () noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a></td></tr>
<tr class="memdesc:ad235ba18dd22c5e094e62a9a5968622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the element following the last element of the reversed container.  <a href="classgul14_1_1SlidingBuffer.html#ad235ba18dd22c5e094e62a9a5968622c">More...</a><br /></td></tr>
<tr class="separator:ad235ba18dd22c5e094e62a9a5968622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29083d647150699f543cdf2f093536eb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a29083d647150699f543cdf2f093536eb">cbegin</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a></td></tr>
<tr class="memdesc:a29083d647150699f543cdf2f093536eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the first element of the container.  <a href="classgul14_1_1SlidingBuffer.html#a29083d647150699f543cdf2f093536eb">More...</a><br /></td></tr>
<tr class="separator:a29083d647150699f543cdf2f093536eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae924d5a9696cff90d66c2388f2b8a546"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ae924d5a9696cff90d66c2388f2b8a546">crbegin</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ae924d5a9696cff90d66c2388f2b8a546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the first element of the reversed container.  <a href="classgul14_1_1SlidingBuffer.html#ae924d5a9696cff90d66c2388f2b8a546">More...</a><br /></td></tr>
<tr class="separator:ae924d5a9696cff90d66c2388f2b8a546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e6256ce0debc120c6b988ed25d52fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe">cend</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a></td></tr>
<tr class="memdesc:a40e6256ce0debc120c6b988ed25d52fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the element following the last element of the container.  <a href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe">More...</a><br /></td></tr>
<tr class="separator:a40e6256ce0debc120c6b988ed25d52fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173da082380357f6cbe1af6bc44dde6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a6173da082380357f6cbe1af6bc44dde6">crend</a> () const noexcept -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6173da082380357f6cbe1af6bc44dde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only iterator to the element following the last element of the reversed container.  <a href="classgul14_1_1SlidingBuffer.html#a6173da082380357f6cbe1af6bc44dde6">More...</a><br /></td></tr>
<tr class="separator:a6173da082380357f6cbe1af6bc44dde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a40aff1991fcc5a9c809988785d645463"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a40aff1991fcc5a9c809988785d645463">change_capacity</a> (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a> new_capacity, <a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a> shrink_behavior=ShrinkBehavior::keep_front_elements) -&gt; void</td></tr>
<tr class="memdesc:a40aff1991fcc5a9c809988785d645463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the underlying container's capacity.  <a href="classgul14_1_1SlidingBuffer.html#a40aff1991fcc5a9c809988785d645463">More...</a><br /></td></tr>
<tr class="separator:a40aff1991fcc5a9c809988785d645463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abf620e6fe6354dfe562c674baee0a203"><td class="memItemLeft" align="right" valign="top"><a id="abf620e6fe6354dfe562c674baee0a203"></a>
<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#abf620e6fe6354dfe562c674baee0a203">idx_begin_</a> { 0u }</td></tr>
<tr class="memdesc:abf620e6fe6354dfe562c674baee0a203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the first <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> element in the underlying container (the one retrieved by <a class="el" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57" title="Return the foremost element (the one with index 0).">SlidingBuffer::front()</a>). <br /></td></tr>
<tr class="separator:abf620e6fe6354dfe562c674baee0a203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8accf4facf2bdb8aa27f01913d25d8"><td class="memItemLeft" align="right" valign="top"><a id="adb8accf4facf2bdb8aa27f01913d25d8"></a>
<a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#adb8accf4facf2bdb8aa27f01913d25d8">idx_end_</a> { 0u }</td></tr>
<tr class="memdesc:adb8accf4facf2bdb8aa27f01913d25d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index pointing to the element in the underlying container that will be written to by the next call to <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a>. <br /></td></tr>
<tr class="separator:adb8accf4facf2bdb8aa27f01913d25d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b6839ee2507846104897bab4df8ed"><td class="memItemLeft" align="right" valign="top"><a id="ac79b6839ee2507846104897bab4df8ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#ac79b6839ee2507846104897bab4df8ed">full_</a> { false }</td></tr>
<tr class="memdesc:ac79b6839ee2507846104897bab4df8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the buffer is completely filled with elements. <br /></td></tr>
<tr class="separator:ac79b6839ee2507846104897bab4df8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063d740550f881f072923a005806fa3c"><td class="memItemLeft" align="right" valign="top"><a id="a063d740550f881f072923a005806fa3c"></a>
Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SlidingBuffer.html#a063d740550f881f072923a005806fa3c">storage_</a> { }</td></tr>
<tr class="memdesc:a063d740550f881f072923a005806fa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual data is stored here, the underlying container. <br /></td></tr>
<tr class="separator:a063d740550f881f072923a005806fa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a758cece56fdc55174a54419e973091b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758cece56fdc55174a54419e973091b1">&#9670;&nbsp;</a></span>SlidingBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty sliding buffer. </p>
<p>The capacity of the buffer is given by the <b><code>fixed_capacity</code></b> template parameter. If that template argument is not zero, a std::array based <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with that (unchangeable) capacity is created.</p>
<p>If the template argument is zero, a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> based on std::vector with a capacity of zero elements is generated. Use the <a class="el" href="classgul14_1_1SlidingBuffer.html#a92e5d070158c684b6a363704d9d4eb7d">SlidingBuffer(size_type)</a> constructor or call the <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a> function afterwards to get a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> based on std::vector with nonzero capacity. </p>

</div>
</div>
<a id="a92e5d070158c684b6a363704d9d4eb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e5d070158c684b6a363704d9d4eb7d">&#9670;&nbsp;</a></span>SlidingBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::<a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Only available for sliding buffers based on std::vector. </p>
<p>Constructs a sliding buffer with a specified capacity.</p>
<p>For std::array based sliding buffers the capacity is specified by the <b><code>fixed_capacity</code></b> template parameter. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d9c21ecd931942bb4c2f1b3ffe58f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9c21ecd931942bb4c2f1b3ffe58f75">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access an element in the buffer by index with bounds checking. </p>
<p>Index 0 is the foremost element, <code><a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a> - 1</code> the backmost one. Access to elements beyond the last one causes an exception to be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is thrown if <code>idx &gt;= <a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__cat__h.html#gad64e01233c1c469a698c36c9e2f89079">gul14::cat()</a>.</p>

</div>
</div>
<a id="af33f9079f10e529b2756d209368a4d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33f9079f10e529b2756d209368a4d04">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the backmost element (the one with the highest valid index). </p>
<p>This call does not check if an element has ever been pushed into the buffer, so it might return a default-constructed element. In the case of a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity, calling <a class="el" href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04" title="Return the backmost element (the one with the highest valid index).">back()</a> results in undefined behavior. </p>

</div>
</div>
<a id="aeffd5a70377ebdc5cecbfc217e94a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffd5a70377ebdc5cecbfc217e94a926">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a>. </p>

</div>
</div>
<a id="addf46f20df776f4770101fdc587ed669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf46f20df776f4770101fdc587ed669">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum possible number of elements in the container. </p>
<p>If the underlying type is std::vector, its size is returned, not its capacity, because only the active elements (i.e. size) participate in the sliding buffer. </p>

</div>
</div>
<a id="a29083d647150699f543cdf2f093536eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29083d647150699f543cdf2f093536eb">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe" title="Return a read-only iterator to the element following the last element of the container.">cend()</a>. </p>

</div>
</div>
<a id="a40e6256ce0debc120c6b988ed25d52fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e6256ce0debc120c6b988ed25d52fe">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a5bba5feb1a0b8a47be93612e4e8960e2">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a40aff1991fcc5a9c809988785d645463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aff1991fcc5a9c809988785d645463">&#9670;&nbsp;</a></span>change_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::change_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the underlying container's capacity. </p>
<p>Only possible if the underlying container is a std::vector.</p>
<ul>
<li>Shrinking: The excess elements are dropped according to <b><code>shrink_behavior</code></b>.</li>
<li>Growing: The capacity changes, but the (used) size does not. It will grow gradually when elements are pushed, as in the startup phase.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>New capacity (maximum size) of the sliding buffer. </td></tr>
    <tr><td class="paramname">shrink_behavior</td><td>Specify the <a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a> </dd></dl>

</div>
</div>
<a id="a9ee0f513eeb009d0cf4f1287bb99b034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee0f513eeb009d0cf4f1287bb99b034">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the buffer. </p>
<p>(Almost) all iterators will be invalidated. See <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Its <a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a> will be zero afterwards. </p>

</div>
</div>
<a id="ae924d5a9696cff90d66c2388f2b8a546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae924d5a9696cff90d66c2388f2b8a546">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the first element of the reversed container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul14_1_1SlidingBuffer.html#a40e6256ce0debc120c6b988ed25d52fe" title="Return a read-only iterator to the element following the last element of the container.">cend()</a>. </p>

</div>
</div>
<a id="a6173da082380357f6cbe1af6bc44dde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173da082380357f6cbe1af6bc44dde6">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a3e17c7b0c76993f335c5a6bb30e18908">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only iterator to the element following the last element of the reversed container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a935b8e8adcf24a828cefcf897f774d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935b8e8adcf24a828cefcf897f774d65">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer contains no elements, i.e. </p>
<p>whether <a class="el" href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926" title="Return an iterator to the first element of the container.">begin()</a> == <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a6dee2dbecac406a8fb2c6d9e82369463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dee2dbecac406a8fb2c6d9e82369463">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#abf2d22595a4e33b8c08ed0add642e540">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a1c3c5e7535ef37b0b22a9e83e167380b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3c5e7535ef37b0b22a9e83e167380b">&#9670;&nbsp;</a></span>filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::filled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the buffer is completely filled with elements. </p>
<p>If the buffer is used in filter contexts this means the filter is fully initialized and working.</p>
<p>If the buffer has zero capacity the value of <a class="el" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b" title="Return true if the buffer is completely filled with elements.">filled()</a> is false. </p>

</div>
</div>
<a id="a8a334331c9384a1ce7ffb37122839c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a334331c9384a1ce7ffb37122839c57">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the foremost element (the one with index 0). </p>
<p>This call does not check if an element has ever been pushed into the buffer, so it might return a default-constructed element. In the case of a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity, calling <a class="el" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57" title="Return the foremost element (the one with index 0).">front()</a> results in undefined behavior. </p>

</div>
</div>
<a id="a06976bd19f36cd1400a70231339954e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06976bd19f36cd1400a70231339954e6">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto friend <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SlidingBuffer.html">SlidingBuffer</a>&lt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a>, fixed_capacity, <a class="el" href="classgul14_1_1SlidingBuffer.html#a61d4fae557fab57f3495f4ef0fc42bac">container_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump all buffer elements. </p>
<p>Shown on the left is <a class="el" href="classgul14_1_1SlidingBuffer.html#a8a334331c9384a1ce7ffb37122839c57" title="Return the foremost element (the one with index 0).">front()</a>, on the right <a class="el" href="classgul14_1_1SlidingBuffer.html#af33f9079f10e529b2756d209368a4d04" title="Return the backmost element (the one with the highest valid index).">back()</a>.</p>
<p>Needs the elements to be dump-able to an ostream. </p>

</div>
</div>
<a id="a7babf297b0f253df5dcfa9ad288a1591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7babf297b0f253df5dcfa9ad288a1591">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#ae3aa68a4157c6d92108ecbec243f35df">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access an element in the buffer by index without bounds checking. </p>
<p>Index 0 is the foremost element, <code><a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a> - 1</code> the backmost one. Access to elements outside the capacity is not allowed and results in undefined behavior. Access to elements inside the capacity is always allowed; a default-constructed element is returned if <code>idx &gt;= <a class="el" href="classgul14_1_1SlidingBuffer.html#a3139cfe59efb599f28326c38c22ab124" title="Return the number of elements in the container, i.e.">size()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested element. </dd></dl>

</div>
</div>
<a id="ae8c4ed682cf26ec3d281b258c941e11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c4ed682cf26ec3d281b258c941e11c">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from the buffer. </p>
<p>The <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a> iterator and any iterators to the last element are invalidated.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul14_1_1SlidingBuffer.html#ae8c4ed682cf26ec3d281b258c941e11c" title="Remove the last element from the buffer.">pop_back()</a> on an empty <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> results in undefined behavior.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.4 </dd></dl>

</div>
</div>
<a id="a50fda19308fc237eedf39b8a83460a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fda19308fc237eedf39b8a83460a86">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first element from the buffer. </p>
<p>The <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a> iterator and any iterators to the last element are invalidated. All other iterators can still be dereferenced, but point to elements that have been shifted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul14_1_1SlidingBuffer.html#a50fda19308fc237eedf39b8a83460a86" title="Remove the first element from the buffer.">pop_front()</a> on an empty <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> results in undefined behavior.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.4 </dd></dl>

</div>
</div>
<a id="afd5dc40066c6e511464d51b2301b203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5dc40066c6e511464d51b2301b203f">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element at the end of the buffer; if it is full, an element at the front is dropped to make room. </p>
<p>At least some iterators can be invalidated. See <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Afterwards all iterators still point to the same logical element (i.e. element[n]).</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a> on a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity results in undefined behavior. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 1.3 </dd></dl>

</div>
</div>
<a id="a0695ad356f048abb6f4f4a9efce293b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0695ad356f048abb6f4f4a9efce293b0">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SlidingBuffer.html#a9ba888ff71b5ae3ab0f97bdb1ff4a424">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element at the front of the buffer; if it is full, an element at the back is dropped to make room. </p>
<p>At least some iterators can be invalidated. See <a class="el" href="classgul14_1_1SlidingBuffer_1_1SlidingBufferIterator.html">SlidingBufferIterator</a>.</p>
<p>Afterwards all iterators still point to the same logical element, while the contents of all logical elements is shifted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> on a <a class="el" href="classgul14_1_1SlidingBuffer.html" title="A circular data buffer of (semi-)fixed capacity to which elements can be added at the front or at the...">SlidingBuffer</a> with zero capacity results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a708896fdb522f58ab5f16f16936bcd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708896fdb522f58ab5f16f16936bcd4f">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element of the reversed container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a>. </p>

</div>
</div>
<a id="ad235ba18dd22c5e094e62a9a5968622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad235ba18dd22c5e094e62a9a5968622c">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a80dee89411602a01b7dfa431d7d7b462">reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the element following the last element of the reversed container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a5290ddbfe6ef4a30cf066c5ec2af937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5290ddbfe6ef4a30cf066c5ec2af937b">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container (identical to <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a> </dd></dl>

</div>
</div>
<a id="aa2bb25710aab15cbd906f775e91772a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bb25710aab15cbd906f775e91772a3">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a>&#160;</td>
          <td class="paramname"><em>shrink_behavior</em> = <code>ShrinkBehavior::keep_front_elements</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the container. </p>
<p>Only possible if the underlying container is a std::vector.</p>
<ul>
<li>Shrinking: The excess elements are dropped according to <b><code>shrink_behavior</code></b>.</li>
<li>Growing: The capacity changes, but the (used) size does not. It will grow gradually when elements are pushed, as in the startup phase.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>New capacity (maximum size) of the sliding buffer. </td></tr>
    <tr><td class="paramname">shrink_behavior</td><td>Specify the <a class="el" href="group__SlidingBuffer__h.html#ga2a276f44539a7a7e2d88c872486e2ff9">ShrinkBehavior</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Think twice when shrinking the buffer: The default <code>shrink_behavior</code> (ShrinkBehavior::keep_front_elements) is transparent only if exclusively <a class="el" href="classgul14_1_1SlidingBuffer.html#a0695ad356f048abb6f4f4a9efce293b0" title="Insert one element at the front of the buffer; if it is full, an element at the back is dropped to ma...">push_front()</a> was used to add elements. If <a class="el" href="classgul14_1_1SlidingBuffer.html#afd5dc40066c6e511464d51b2301b203f" title="Insert one element at the end of the buffer; if it is full, an element at the front is dropped to mak...">push_back()</a> was used, <a class="el" href="classgul14_1_1SlidingBuffer.html#aa2bb25710aab15cbd906f775e91772a3" title="Resize the container.">resize()</a> without a second argument discards the most recent elements; in these cases, make sure to specify ShrinkBehavior::keep_back_elements. </dd></dl>

</div>
</div>
<a id="a3139cfe59efb599f28326c38c22ab124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3139cfe59efb599f28326c38c22ab124">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , std::size_t fixed_capacity = 0u, typename Container  = typename std::conditional_t&lt;(fixed_capacity &gt;= 1u),        std::array&lt;ElementT, fixed_capacity&gt;,        std::vector&lt;ElementT&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classgul14_1_1SlidingBuffer.html">gul14::SlidingBuffer</a>&lt; ElementT, fixed_capacity, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classgul14_1_1SlidingBuffer.html#a1132f5141a579296c1db4bc7de953df2">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in the container, i.e. </p>
<p>std::distance(<a class="el" href="classgul14_1_1SlidingBuffer.html#aeffd5a70377ebdc5cecbfc217e94a926" title="Return an iterator to the first element of the container.">begin()</a>, <a class="el" href="classgul14_1_1SlidingBuffer.html#a6dee2dbecac406a8fb2c6d9e82369463" title="Return an iterator to the element following the last element of the container.">end()</a>).</p>
<p>In the startup phase it can be 0 and up to the <b><code>fixed_capacity</code></b> or <a class="el" href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669" title="Return the maximum possible number of elements in the container.">capacity()</a>, after startup (<a class="el" href="classgul14_1_1SlidingBuffer.html#a1c3c5e7535ef37b0b22a9e83e167380b" title="Return true if the buffer is completely filled with elements.">filled()</a> == true) it will always return <b><code>fixed_capacity</code></b> resp. <a class="el" href="classgul14_1_1SlidingBuffer.html#addf46f20df776f4770101fdc587ed669" title="Return the maximum possible number of elements in the container.">capacity()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SlidingBuffer_8h_source.html">SlidingBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++14 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
