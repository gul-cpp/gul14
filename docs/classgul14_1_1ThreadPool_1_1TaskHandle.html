<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++14: gul14::ThreadPool::TaskHandle&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul14.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++14
   &#160;<span id="projectnumber">2.13</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul14.html">gul14</a></li><li class="navelem"><a class="el" href="classgul14_1_1ThreadPool.html">ThreadPool</a></li><li class="navelem"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgul14_1_1ThreadPool_1_1TaskHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gul14::ThreadPool::TaskHandle&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class gul14::ThreadPool::TaskHandle&lt; T &gt;</h3>

<p>A handle for a task that has (or had) been enqueued on a <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a>. </p>
<p>A <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a> can be used to query the status of a task and to retrieve its result.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pool = <a class="code" href="group__ThreadPool__h.html#ga166ce288cf81fd766bcd83b148ef0af5">make_thread_pool</a>(1);</div>
<div class="line"><span class="keyword">auto</span> task = pool-&gt;add_task([]() { <span class="keywordflow">return</span> 42; });</div>
<div class="line"><span class="keywordflow">while</span> (not task.is_complete())</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for task to complete...\n&quot;</span>;</div>
<div class="line">    <a class="code" href="group__time__util__h.html#gaa0abe7bf6452e6882c0e0b0d05897adc">sleep</a>(0.1);</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Task result: &quot;</span> &lt;&lt; task.get_result() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="agroup__ThreadPool__h_html_ga166ce288cf81fd766bcd83b148ef0af5"><div class="ttname"><a href="group__ThreadPool__h.html#ga166ce288cf81fd766bcd83b148ef0af5">gul14::make_thread_pool</a></div><div class="ttdeci">std::shared_ptr&lt; ThreadPool &gt; make_thread_pool(std::size_t num_threads, std::size_t capacity=ThreadPool::default_capacity)</div><div class="ttdoc">Create a thread pool with the desired number of threads and the specified capacity for queuing tasks.</div><div class="ttdef"><b>Definition:</b> ThreadPool.h:625</div></div>
<div class="ttc" id="agroup__time__util__h_html_gaa0abe7bf6452e6882c0e0b0d05897adc"><div class="ttname"><a href="group__time__util__h.html#gaa0abe7bf6452e6882c0e0b0d05897adc">gul14::sleep</a></div><div class="ttdeci">bool sleep(const std::chrono::duration&lt; Rep, Period &gt; &amp;duration, const Trigger &amp;trg)</div><div class="ttdoc">Sleep for at least the given time span, with the option of being woken up from another thread.</div><div class="ttdef"><b>Definition:</b> time_util.h:114</div></div>
</div><!-- fragment --> </div>
<p><code>#include &lt;<a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a398fe0d6d681e2589040a75039fdba73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a398fe0d6d681e2589040a75039fdba73">TaskHandle</a> ()</td></tr>
<tr class="memdesc:a398fe0d6d681e2589040a75039fdba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-construct an invalid <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a398fe0d6d681e2589040a75039fdba73">More...</a><br /></td></tr>
<tr class="separator:a398fe0d6d681e2589040a75039fdba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e68a67b7c7f762111b57bf861974a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#aa17e68a67b7c7f762111b57bf861974a">TaskHandle</a> (<a class="el" href="classgul14_1_1ThreadPool.html#a0d3ecad622a33e862b4696f02bf69e98">TaskId</a> id, std::future&lt; T &gt; future, std::shared_ptr&lt; <a class="el" href="classgul14_1_1ThreadPool.html">ThreadPool</a> &gt; pool)</td></tr>
<tr class="memdesc:aa17e68a67b7c7f762111b57bf861974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#aa17e68a67b7c7f762111b57bf861974a">More...</a><br /></td></tr>
<tr class="separator:aa17e68a67b7c7f762111b57bf861974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359c7eb6fdfa651d57918285c59e4dcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a359c7eb6fdfa651d57918285c59e4dcc">cancel</a> ()</td></tr>
<tr class="memdesc:a359c7eb6fdfa651d57918285c59e4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the task from the queue if it is still pending.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a359c7eb6fdfa651d57918285c59e4dcc">More...</a><br /></td></tr>
<tr class="separator:a359c7eb6fdfa651d57918285c59e4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e993de5a9b39db73138a25437d8d7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a063e993de5a9b39db73138a25437d8d7">get_result</a> ()</td></tr>
<tr class="memdesc:a063e993de5a9b39db73138a25437d8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the task has finished and return its result.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a063e993de5a9b39db73138a25437d8d7">More...</a><br /></td></tr>
<tr class="separator:a063e993de5a9b39db73138a25437d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606141e396d66f48cc168592fe8aee18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a606141e396d66f48cc168592fe8aee18">is_complete</a> () const</td></tr>
<tr class="memdesc:a606141e396d66f48cc168592fe8aee18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the task has completed.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a606141e396d66f48cc168592fe8aee18">More...</a><br /></td></tr>
<tr class="separator:a606141e396d66f48cc168592fe8aee18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9786409079160b8bff3cf6143a9b1c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ThreadPool__h.html#ga6ea1dc7329cb2e4f40ae6b268ef9ab55">TaskState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a9786409079160b8bff3cf6143a9b1c0e">get_state</a> () const</td></tr>
<tr class="memdesc:a9786409079160b8bff3cf6143a9b1c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the task is running, waiting to be started, completed, or has been canceled.  <a href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a9786409079160b8bff3cf6143a9b1c0e">More...</a><br /></td></tr>
<tr class="separator:a9786409079160b8bff3cf6143a9b1c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a398fe0d6d681e2589040a75039fdba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398fe0d6d681e2589040a75039fdba73">&#9670;&nbsp;</a></span>TaskHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::<a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default-construct an invalid <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>. </p>
<p>This constructor creates an invalid <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a> which has no result and is not associated with a <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a>. </p>

</div>
</div>
<a id="aa17e68a67b7c7f762111b57bf861974a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17e68a67b7c7f762111b57bf861974a">&#9670;&nbsp;</a></span>TaskHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::<a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">TaskHandle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1ThreadPool.html#a0d3ecad622a33e862b4696f02bf69e98">TaskId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::future&lt; T &gt;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgul14_1_1ThreadPool.html">ThreadPool</a> &gt;&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html" title="A handle for a task that has (or had) been enqueued on a ThreadPool.">TaskHandle</a>. </p>
<p>This constructor is not meant to be used directly. Instead, TaskHandles are returned by the <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> when a task is enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique ID of the task </td></tr>
    <tr><td class="paramname">future</td><td>A std::future that will eventually contain the result of the task </td></tr>
    <tr><td class="paramname">pool</td><td>A shared pointer to the <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> that the task is associated with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a359c7eb6fdfa651d57918285c59e4dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359c7eb6fdfa651d57918285c59e4dcc">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the task from the queue if it is still pending. </p>
<p>This call has no effect if the task is already running.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the task was removed from the queue, false if it was not found in the queue (e.g. because it is already running).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>is thrown if the associated thread pool does not exist anymore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063e993de5a9b39db73138a25437d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063e993de5a9b39db73138a25437d8d7">&#9670;&nbsp;</a></span>get_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::get_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until the task has finished and return its result. </p>
<p>If <code><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a606141e396d66f48cc168592fe8aee18" title="Determine whether the task has completed.">is_complete()</a> == true</code>, the result is available immediately. If the task finished by throwing an exception, <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a063e993de5a9b39db73138a25437d8d7" title="Block until the task has finished and return its result.">get_result()</a> rethrows this exception. </p>

</div>
</div>
<a id="a9786409079160b8bff3cf6143a9b1c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9786409079160b8bff3cf6143a9b1c0e">&#9670;&nbsp;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ThreadPool__h.html#ga6ea1dc7329cb2e4f40ae6b268ef9ab55">TaskState</a> <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the task is running, waiting to be started, completed, or has been canceled. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>is thrown if the associated thread pool does not exist anymore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you just need to find out if a task has finished running, prefer <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a606141e396d66f48cc168592fe8aee18" title="Determine whether the task has completed.">is_complete()</a> over this function. It does not need to interact with the <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> and is therefore slightly more performant. </dd></dl>

</div>
</div>
<a id="a606141e396d66f48cc168592fe8aee18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606141e396d66f48cc168592fe8aee18">&#9670;&nbsp;</a></span>is_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html">gul14::ThreadPool::TaskHandle</a>&lt; T &gt;::is_complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the task has completed. </p>
<p>This function returns true if the task has finished, either successfully or by throwing an exception. It returns false if the task is still running, waiting to be started, or has been canceled.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a606141e396d66f48cc168592fe8aee18" title="Determine whether the task has completed.">is_complete()</a> does not need to interact with the <a class="el" href="classgul14_1_1ThreadPool.html" title="A pool of worker threads with a task queue.">ThreadPool</a> to determine the state of the task. It is therefore slightly more performant than <a class="el" href="classgul14_1_1ThreadPool_1_1TaskHandle.html#a9786409079160b8bff3cf6143a9b1c0e" title="Determine if the task is running, waiting to be started, completed, or has been canceled.">get_state()</a>, but does not deliver the same fine-grained information. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ThreadPool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++14 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
