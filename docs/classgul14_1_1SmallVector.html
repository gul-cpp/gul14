<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>General Utility Library for C++14: gul14::SmallVector&lt; ElementT, in_capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gul14.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">General Utility Library for C++14
   &#160;<span id="projectnumber">2.13</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegul14.html">gul14</a></li><li class="navelem"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgul14_1_1SmallVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gul14::SmallVector&lt; ElementT, in_capacity &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__SmallVector__h.html">gul14/SmallVector.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ElementT, size_t in_capacity&gt;<br />
class gul14::SmallVector&lt; ElementT, in_capacity &gt;</h3>

<p>A resizable container with contiguous storage that can hold a specified number of elements without allocating memory on the heap. </p>
<p>A <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> is very similar to a std::vector, but it can store a small number of elements within the object itself, similar to a std::array. If the number of elements exceeds this <em>inner capacity</em> (<a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> &gt; <a class="el" href="classgul14_1_1SmallVector.html#aa90eed50ef66c1960f978b240353163c" title="Return the number of elements this SmallVector can hold internally without having to allocate storage...">inner_capacity()</a>), the elements are stored on the heap as in a conventional std::vector.</p>
<p><a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> mimicks the API of std::vector closely, but it does not support allocators. It also uses 32-bit integers for storing the number of elements and capacity. On 64-bit systems, this makes the object slightly more memory efficient and lets it store less elements.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a buffer which can store up to 3 entries without allocating</span></div>
<div class="line">SmallVector&lt;int, 3&gt; buf;</div>
<div class="line"> </div>
<div class="line">buf.push_back(1);</div>
<div class="line">buf.push_back(2);</div>
<div class="line">buf.push_back(3); <span class="comment">// So far, no heap allocation has taken place</span></div>
<div class="line"> </div>
<div class="line">buf.push_back(4); <span class="comment">// Moves all elements into newly allocated memory</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementT</td><td>Type of the elements to be stored in the container </td></tr>
    <tr><td class="paramname">in_capacity</td><td>The number of elements that can be stored directly in the object without allocating (the "inner capacity")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GUL version 2.5</dd></dl>
<h3>Member function overview</h3>
<table style="border-style: none;">
<tr>
<th colspan="2">Construction &amp; destruction </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a9a7d45b5344dd40cf90b84ac22bd9393" title="Construct an empty SmallVector.">SmallVector()</a> </td><td>Construct an empty <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571" title="Construct a SmallVector that is filled with a certain number of default-initialized elements.">SmallVector(SizeType)</a> </td><td>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of default-initialized elements </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a9d5deabac040e12fa5af89195617c426" title="Construct a SmallVector that is filled with a certain number of copies of the given value.">SmallVector(SizeType, const ValueType&amp;)</a> </td><td>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of copies of the given value </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#aa22f275b8ef1077f144ab524b01b2b6a" title="Construct a SmallVector that is filled with copies of elements from the given range.">SmallVector(InputIterator, InputIterator)</a> </td><td>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with copies of elements from the given range </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#afea05971fb194b17366d056ba7a37990" title="Create a copy of another SmallVector with the same inner capacity.">SmallVector(const SmallVector&amp;)</a> </td><td>Copy constructor </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#af743bb3649edfa476b380053bd5bbc9f" title="Move constructor: Create a SmallVector from the contents of another one with the same inner capacity ...">SmallVector(SmallVector&amp;&amp;)</a> </td><td>Move constructor </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ab4c5473cacc32dcffbe8a30595e671f6" title="Construct a SmallVector that is filled with copies of the elements from a given initializer list.">SmallVector(std::initializer_list&lt;ValueType&gt;)</a> </td><td>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> from an initializer list </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6476df76f72bf67afbea23803075be46" title="Destructor: Destroys all stored elements and frees all allocated memory.">~SmallVector()</a> </td><td>Destructor </td></tr>
<tr>
<th colspan="2">Assignment </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39" title="Fill the vector with a certain number of copies of the given value after clearing all previous conten...">assign(SizeType, const ValueType&amp;)</a> </td><td>Assign a certain number of copies of the given value </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#adbb09ec0e11af004813764070e08670f" title="Fill the vector with copies of elements from the given range.">assign(InputIterator, InputIterator)</a> </td><td>Assign copies of the elements from the given range </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a74a23a2543f50d0fc3148e2847db76e0" title="Assign the elements of an initializer list to this vector after clearing all previous contents.">assign(std::initializer_list&lt;ValueType&gt;)</a> </td><td>Assign the contents of an initializer list </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4" title="Copy assignment operator: Copy all elements from another SmallVector after clearing all previous cont...">operator=(SmallVector const&amp;)</a> </td><td>Copy assignment </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a0aa2646f94d9beefbf094f5839bf78cc" title="Move assignment operator: Assign all of the elements from another vector to this one using move seman...">operator=(SmallVector&amp;&amp;)</a> </td><td>Move assignment </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a39c745720e2a690aecd2415907148613" title="Assign the elements of an initializer list to this vector after clearing all previous contents.">operator=(std::initializer_list&lt;ValueType&gt;)</a> </td><td>Assign the contents of an initializer list </td></tr>
<tr>
<th colspan="2">Element access </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ae722acdb89c05d9caa14ddfac567555d" title="Return a reference to the element at the specified index.">operator[](SizeType)</a> </td><td>Access an element by index without bounds-checking </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a4ca0b25404a79967d68fff9dbe1b9207" title="Return a reference to the element at the specified index with bounds-checking.">at(SizeType)</a> </td><td>Access an element by index with bounds-checking </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#aed3cd309f9f12f9724d52a9efd7c7915" title="Return a reference to the first element in the vector.">front()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a54954a5e90f6248c5c76a43a25b9e29d" title="Return a reference to the last element in the vector.">back()</a> </td><td>Access the first/last element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d" title="Return a pointer to the contiguous data storage of the vector.">data()</a> </td><td>Return a pointer to the contiguous data storage </td></tr>
<tr>
<th colspan="2">Iterators </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1" title="Return an iterator to the first element of the vector.">begin()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ac653df69ec38aa62495f2472481df602" title="Return a const iterator to the first element of the vector.">cbegin()</a> </td><td>Return an iterator to the first element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a873547dc12fb5e79e6cf87fc3e651b11" title="Return a const iterator pointing past the last element of the vector.">cend()</a> </td><td>Return an iterator past the last element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a15d2ed4feae2aa55f90357c259671201" title="Return a reverse iterator to the first element of the reversed vector (which is the last element of t...">rbegin()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ac82e7410d66f66f7fb0b6c78f75e62bc" title="Return a const reverse iterator to the first element of the reversed vector (which is the last elemen...">crbegin()</a> </td><td>Return an iterator to the first element of the reversed vector </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6ac818e47b8b7f85df461ed16d924570" title="Return a reverse iterator pointing past the last element of the reversed vector.">rend()</a>, <a class="el" href="classgul14_1_1SmallVector.html#af7e77395dbceb2e8ccc83698c5755bb5" title="Return a const reverse iterator pointing past the last element of the reversed vector.">crend()</a> </td><td>Return an iterator past the last element of the reversed vector </td></tr>
<tr>
<th colspan="2">Size &amp; capacity </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a> </td><td>Return the number of elements that can currently be stored without allocating more memory </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a85874f791bb5b3554697d77accfcbf69" title="Determine if the vector is empty.">empty()</a> </td><td>Determine if the vector is empty </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#aa90eed50ef66c1960f978b240353163c" title="Return the number of elements this SmallVector can hold internally without having to allocate storage...">inner_capacity()</a> </td><td>Return the number of elements that can be stored internally without allocating heap memory </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a> </td><td>Return the maximum number of elements that can theoretically be stored </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924" title="Increase the capacity of the vector to the specified size.">reserve(SizeType)</a> </td><td>Increase the capacity of the vector to the specified size </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781" title="Change the number of elements in the container.">resize(SizeType)</a> </td><td>Change the number of elements, filling up with default-constructed elements if necessary </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#aa44053f66c8700034cf7905a8ecd868d" title="Change the number of elements in the container.">resize(SizeType, const ValueType&amp;)</a> </td><td>Change the number of elements, filling up with copy-constructed elements if necessary </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ab7bc0e29dcd54fca0321322389b2a6f7" title="Reduce the capacity as far as possible while retaining all stored elements.">shrink_to_fit()</a> </td><td>Reduce the capacity as far as possible while retaining all stored elements </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> </td><td>Return the number of elements that are currently stored </td></tr>
<tr>
<th colspan="2">Content modification </th></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc" title="Erase all elements from the container without changing its capacity.">clear()</a> </td><td>Erase all elements without changing capacity </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70">emplace(ConstIterator, ArgumentTypes&amp;&amp;...)</a> </td><td>Construct an additional element at an arbitrary position </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180">emplace_back(ArgumentTypes&amp;&amp;...)</a> </td><td>Construct an additional element at the end </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a10c77321c8609dd58d793ca16ab1d1e4" title="Erase a single element from the vector, moving elements behind it forward.">erase(ConstIterator)</a> </td><td>Erase a single element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6bd1e01c26dd90503888a541b7d2ad62" title="Erase a range of elements from the vector, moving elements behind the range forward.">erase(ConstIterator, ConstIterator)</a> </td><td>Erase a range of elements </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a88a70ad212b2d653e5fc08832d6acea6" title="Insert a single element before the indicated position.">insert(ConstIterator, const ValueType&amp;)</a> </td><td>Copy-insert a single element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ad1d46c8ca495b892e6884607b1f25a6f" title="Insert a single element before the indicated position.">insert(ConstIterator, ValueType&amp;&amp;)</a> </td><td>Move-insert a single element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a2cfaeb533db143ae2ae2ff5005f7b049" title="Insert a number of copies of the given value before the indicated position.">insert(ConstIterator, SizeType, const ValueType&amp;)</a> </td><td>Insert a number of copies of a given value </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a4fdd84e8f4d93bf5eb62bf8cf903db75" title="Insert a range of values before the indicated position.">insert(ConstIterator, InputIterator, InputIterator)</a> </td><td>Insert a range of values </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a5b6fb189060f149c88b077b28969d0b3" title="Insert elements from an initializer list before the indicated position.">insert(ConstIterator, std::initializer_list&lt;ValueType&gt;)</a> </td><td>Insert elements from an initializer list </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a34aa01cac20ad5a59cb79064af614d48" title="Remove the last element from the vector.">pop_back()</a> </td><td>Remove the last element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#af8e015b0e0da2198597503ccfa69f92b" title="Copy one element to the end of the buffer.">push_back(const ValueType&amp;)</a> </td><td>Copy-insert one element at the end </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ac0b231cc722f49a114f1a1dd4427a3b3" title="Move one element to the end of the buffer.">push_back(ValueType&amp;&amp;)</a> </td><td>Move-insert one element at the end </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6ac0fa47638f2ad8e70172fa71fcbd77" title="Exchange the contents of this SmallVector with those of another one.">swap(SmallVector&amp;)</a> </td><td>Exchange the contents of this <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one  </td></tr>
</table>
<h3>Associated free functions</h3>
<table style="border-style: none;">
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a556093ed0d8700acfa03836278ee1638" title="Equality operator: Return true if both vectors have the same size() and the same elements.">operator==(const SmallVector&amp;, const SmallVector&amp;)</a> </td><td>Return true if both vectors have the same <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> and the same elements </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a16efde1ad04ee2e65d30506dfd7aacc0" title="Inequality operator: Return true if both vectors have a different size() or at least one different el...">operator!=(const SmallVector&amp;, const SmallVector&amp;)</a> </td><td>Return true if both vectors have a different <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> or at least one different element </td></tr>
<tr>
<td><a class="el" href="group__SmallVector__h.html#ga4074913afff7c8698358785771ab61db" title="Exchange the contents of one SmallVector with those of another one.">swap(SmallVector&amp;, SmallVector&amp;)</a> </td><td>Exchange the contents two SmallVectors  </td></tr>
</table>
<h3>Member type overview</h3>
<table style="border-style: none;">
<tr>
<td colspan="3">Member types are available in both CamelCase and snake_case. </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a8764c49ed633f9d63221c1f4b3968ec7">value_type</a> </td><td>Type of the elements in the underlying container </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a7e03ad8b3216b23912296b6d8a0d7cca">size_type</a> </td><td>Unsigned integer type for indexing, number of elements, capacity </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#af109141bbfb4a1e1079d8d925e6ad25a">DifferenceType</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a6e92eb526722ba60bbffacc1d11db276">difference_type</a> </td><td>Signed integer type for storing the difference of two iterators </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#aad1d72d4276793826e01422cd3e5d0c7">reference</a> </td><td>Reference to an element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a89449b60742cb7ed9cff3912ba07e6f5">const_reference</a> </td><td>Reference to a const element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a0a7d96f0979a0096999c3965cd2a8a88">iterator</a> </td><td>Iterator to an element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a72d363425fbe5e551547d76116e6a318">const_iterator</a> </td><td>Iterator to a const element </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a> </td><td><a class="el" href="classgul14_1_1SmallVector.html#a3310e4d386a343beade052e2be0ad29b">reverse_iterator</a> </td><td>Iterator to an element in reversed container </td></tr>
<tr>
<td><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a></td><td><a class="el" href="classgul14_1_1SmallVector.html#af31269c1d7c63fc9f2f26e5b2ce4f566">const_reverse_iterator</a></td><td>Iterator to a const element in reversed container </td></tr>
</table>
</div>
<p><code>#include &lt;<a class="el" href="SmallVector_8h_source.html">SmallVector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7554e6d5690b059c6573a3205325218d"><td class="memItemLeft" align="right" valign="top"><a id="a7554e6d5690b059c6573a3205325218d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> = ElementT</td></tr>
<tr class="memdesc:a7554e6d5690b059c6573a3205325218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in the underlying container. <br /></td></tr>
<tr class="separator:a7554e6d5690b059c6573a3205325218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8764c49ed633f9d63221c1f4b3968ec7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a8764c49ed633f9d63221c1f4b3968ec7">value_type</a> = <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a></td></tr>
<tr class="memdesc:a8764c49ed633f9d63221c1f4b3968ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in the underlying container.  <a href="classgul14_1_1SmallVector.html#a8764c49ed633f9d63221c1f4b3968ec7">More...</a><br /></td></tr>
<tr class="separator:a8764c49ed633f9d63221c1f4b3968ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b053c83472b979b17dfe047b32fba0"><td class="memItemLeft" align="right" valign="top"><a id="a40b053c83472b979b17dfe047b32fba0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> = uint32_t</td></tr>
<tr class="memdesc:a40b053c83472b979b17dfe047b32fba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type for indexing, number of elements, capacity. <br /></td></tr>
<tr class="separator:a40b053c83472b979b17dfe047b32fba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e03ad8b3216b23912296b6d8a0d7cca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a7e03ad8b3216b23912296b6d8a0d7cca">size_type</a> = <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a></td></tr>
<tr class="memdesc:a7e03ad8b3216b23912296b6d8a0d7cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type for indexing, number of elements, capacity.  <a href="classgul14_1_1SmallVector.html#a7e03ad8b3216b23912296b6d8a0d7cca">More...</a><br /></td></tr>
<tr class="separator:a7e03ad8b3216b23912296b6d8a0d7cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af109141bbfb4a1e1079d8d925e6ad25a"><td class="memItemLeft" align="right" valign="top"><a id="af109141bbfb4a1e1079d8d925e6ad25a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af109141bbfb4a1e1079d8d925e6ad25a">DifferenceType</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:af109141bbfb4a1e1079d8d925e6ad25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type for the difference of two iterators. <br /></td></tr>
<tr class="separator:af109141bbfb4a1e1079d8d925e6ad25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92eb526722ba60bbffacc1d11db276"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6e92eb526722ba60bbffacc1d11db276">difference_type</a> = <a class="el" href="classgul14_1_1SmallVector.html#af109141bbfb4a1e1079d8d925e6ad25a">DifferenceType</a></td></tr>
<tr class="memdesc:a6e92eb526722ba60bbffacc1d11db276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type for the difference of two iterators.  <a href="classgul14_1_1SmallVector.html#a6e92eb526722ba60bbffacc1d11db276">More...</a><br /></td></tr>
<tr class="separator:a6e92eb526722ba60bbffacc1d11db276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6deadff25be00e7f058cf651837f256"><td class="memItemLeft" align="right" valign="top"><a id="aa6deadff25be00e7f058cf651837f256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> = <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;</td></tr>
<tr class="memdesc:aa6deadff25be00e7f058cf651837f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to an element. <br /></td></tr>
<tr class="separator:aa6deadff25be00e7f058cf651837f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1d72d4276793826e01422cd3e5d0c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aad1d72d4276793826e01422cd3e5d0c7">reference</a> = <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a></td></tr>
<tr class="memdesc:aad1d72d4276793826e01422cd3e5d0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to an element.  <a href="classgul14_1_1SmallVector.html#aad1d72d4276793826e01422cd3e5d0c7">More...</a><br /></td></tr>
<tr class="separator:aad1d72d4276793826e01422cd3e5d0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb0d9cf9e1551b71c6b171b47daa40d"><td class="memItemLeft" align="right" valign="top"><a id="a4fb0d9cf9e1551b71c6b171b47daa40d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a> = const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;</td></tr>
<tr class="memdesc:a4fb0d9cf9e1551b71c6b171b47daa40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a const element. <br /></td></tr>
<tr class="separator:a4fb0d9cf9e1551b71c6b171b47daa40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89449b60742cb7ed9cff3912ba07e6f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a89449b60742cb7ed9cff3912ba07e6f5">const_reference</a> = <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a></td></tr>
<tr class="memdesc:a89449b60742cb7ed9cff3912ba07e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a const element.  <a href="classgul14_1_1SmallVector.html#a89449b60742cb7ed9cff3912ba07e6f5">More...</a><br /></td></tr>
<tr class="separator:a89449b60742cb7ed9cff3912ba07e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a736e2f7bd751de4e51e7944c422ea0"><td class="memItemLeft" align="right" valign="top"><a id="a6a736e2f7bd751de4e51e7944c422ea0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> = <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> *</td></tr>
<tr class="memdesc:a6a736e2f7bd751de4e51e7944c422ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element. <br /></td></tr>
<tr class="separator:a6a736e2f7bd751de4e51e7944c422ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d96f0979a0096999c3965cd2a8a88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a0a7d96f0979a0096999c3965cd2a8a88">iterator</a> = <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a></td></tr>
<tr class="memdesc:a0a7d96f0979a0096999c3965cd2a8a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element.  <a href="classgul14_1_1SmallVector.html#a0a7d96f0979a0096999c3965cd2a8a88">More...</a><br /></td></tr>
<tr class="separator:a0a7d96f0979a0096999c3965cd2a8a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e6fd265c462692df44454c3774a544"><td class="memItemLeft" align="right" valign="top"><a id="a98e6fd265c462692df44454c3774a544"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> = const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> *</td></tr>
<tr class="memdesc:a98e6fd265c462692df44454c3774a544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element. <br /></td></tr>
<tr class="separator:a98e6fd265c462692df44454c3774a544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d363425fbe5e551547d76116e6a318"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a72d363425fbe5e551547d76116e6a318">const_iterator</a> = <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a></td></tr>
<tr class="memdesc:a72d363425fbe5e551547d76116e6a318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element.  <a href="classgul14_1_1SmallVector.html#a72d363425fbe5e551547d76116e6a318">More...</a><br /></td></tr>
<tr class="separator:a72d363425fbe5e551547d76116e6a318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad609da079115c0ec6f559ceb945770db"><td class="memItemLeft" align="right" valign="top"><a id="ad609da079115c0ec6f559ceb945770db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> &gt;</td></tr>
<tr class="memdesc:ad609da079115c0ec6f559ceb945770db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element in reversed container. <br /></td></tr>
<tr class="separator:ad609da079115c0ec6f559ceb945770db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3310e4d386a343beade052e2be0ad29b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a3310e4d386a343beade052e2be0ad29b">reverse_iterator</a> = <a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a></td></tr>
<tr class="memdesc:a3310e4d386a343beade052e2be0ad29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to an element in reversed container.  <a href="classgul14_1_1SmallVector.html#a3310e4d386a343beade052e2be0ad29b">More...</a><br /></td></tr>
<tr class="separator:a3310e4d386a343beade052e2be0ad29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951844dc268183f7f2cba2a9c643e9fd"><td class="memItemLeft" align="right" valign="top"><a id="a951844dc268183f7f2cba2a9c643e9fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a> = std::reverse_iterator&lt; <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> &gt;</td></tr>
<tr class="memdesc:a951844dc268183f7f2cba2a9c643e9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element in reversed container. <br /></td></tr>
<tr class="separator:a951844dc268183f7f2cba2a9c643e9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31269c1d7c63fc9f2f26e5b2ce4f566"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af31269c1d7c63fc9f2f26e5b2ce4f566">const_reverse_iterator</a> = <a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a></td></tr>
<tr class="memdesc:af31269c1d7c63fc9f2f26e5b2ce4f566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to a const element in reversed container.  <a href="classgul14_1_1SmallVector.html#af31269c1d7c63fc9f2f26e5b2ce4f566">More...</a><br /></td></tr>
<tr class="separator:af31269c1d7c63fc9f2f26e5b2ce4f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a7d45b5344dd40cf90b84ac22bd9393"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a9a7d45b5344dd40cf90b84ac22bd9393">SmallVector</a> () noexcept=default</td></tr>
<tr class="memdesc:a9a7d45b5344dd40cf90b84ac22bd9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a>.  <a href="classgul14_1_1SmallVector.html#a9a7d45b5344dd40cf90b84ac22bd9393">More...</a><br /></td></tr>
<tr class="separator:a9a7d45b5344dd40cf90b84ac22bd9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e006aadaf59912c25a0a0be4e59571"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571">SmallVector</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements)</td></tr>
<tr class="memdesc:a79e006aadaf59912c25a0a0be4e59571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of default-initialized elements.  <a href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571">More...</a><br /></td></tr>
<tr class="separator:a79e006aadaf59912c25a0a0be4e59571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5deabac040e12fa5af89195617c426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a9d5deabac040e12fa5af89195617c426">SmallVector</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements, const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a9d5deabac040e12fa5af89195617c426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of copies of the given value.  <a href="classgul14_1_1SmallVector.html#a9d5deabac040e12fa5af89195617c426">More...</a><br /></td></tr>
<tr class="separator:a9d5deabac040e12fa5af89195617c426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f275b8ef1077f144ab524b01b2b6a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aa22f275b8ef1077f144ab524b01b2b6a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aa22f275b8ef1077f144ab524b01b2b6a">SmallVector</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:aa22f275b8ef1077f144ab524b01b2b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with copies of elements from the given range.  <a href="classgul14_1_1SmallVector.html#aa22f275b8ef1077f144ab524b01b2b6a">More...</a><br /></td></tr>
<tr class="separator:aa22f275b8ef1077f144ab524b01b2b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea05971fb194b17366d056ba7a37990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#afea05971fb194b17366d056ba7a37990">SmallVector</a> (const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;other) noexcept(std::is_nothrow_copy_constructible&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;::value)</td></tr>
<tr class="memdesc:afea05971fb194b17366d056ba7a37990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of another <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with the same inner capacity.  <a href="classgul14_1_1SmallVector.html#afea05971fb194b17366d056ba7a37990">More...</a><br /></td></tr>
<tr class="separator:afea05971fb194b17366d056ba7a37990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af743bb3649edfa476b380053bd5bbc9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af743bb3649edfa476b380053bd5bbc9f">SmallVector</a> (<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;&amp;other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;::value)</td></tr>
<tr class="memdesc:af743bb3649edfa476b380053bd5bbc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor: Create a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> from the contents of another one with the same inner capacity using move semantics.  <a href="classgul14_1_1SmallVector.html#af743bb3649edfa476b380053bd5bbc9f">More...</a><br /></td></tr>
<tr class="separator:af743bb3649edfa476b380053bd5bbc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c5473cacc32dcffbe8a30595e671f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ab4c5473cacc32dcffbe8a30595e671f6">SmallVector</a> (std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt; init)</td></tr>
<tr class="memdesc:ab4c5473cacc32dcffbe8a30595e671f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with copies of the elements from a given initializer list.  <a href="classgul14_1_1SmallVector.html#ab4c5473cacc32dcffbe8a30595e671f6">More...</a><br /></td></tr>
<tr class="separator:ab4c5473cacc32dcffbe8a30595e671f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6476df76f72bf67afbea23803075be46"><td class="memItemLeft" align="right" valign="top"><a id="a6476df76f72bf67afbea23803075be46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6476df76f72bf67afbea23803075be46">~SmallVector</a> ()</td></tr>
<tr class="memdesc:a6476df76f72bf67afbea23803075be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: Destroys all stored elements and frees all allocated memory. <br /></td></tr>
<tr class="separator:a6476df76f72bf67afbea23803075be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373fc10db415ce3f15c51f9b7196a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39">assign</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements, const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a5373fc10db415ce3f15c51f9b7196a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with a certain number of copies of the given value after clearing all previous contents.  <a href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39">More...</a><br /></td></tr>
<tr class="separator:a5373fc10db415ce3f15c51f9b7196a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb09ec0e11af004813764070e08670f"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adbb09ec0e11af004813764070e08670f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#adbb09ec0e11af004813764070e08670f">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:adbb09ec0e11af004813764070e08670f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the vector with copies of elements from the given range.  <a href="classgul14_1_1SmallVector.html#adbb09ec0e11af004813764070e08670f">More...</a><br /></td></tr>
<tr class="separator:adbb09ec0e11af004813764070e08670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a23a2543f50d0fc3148e2847db76e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a74a23a2543f50d0fc3148e2847db76e0">assign</a> (std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt; init)</td></tr>
<tr class="memdesc:a74a23a2543f50d0fc3148e2847db76e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of an initializer list to this vector after clearing all previous contents.  <a href="classgul14_1_1SmallVector.html#a74a23a2543f50d0fc3148e2847db76e0">More...</a><br /></td></tr>
<tr class="separator:a74a23a2543f50d0fc3148e2847db76e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca0b25404a79967d68fff9dbe1b9207"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a4ca0b25404a79967d68fff9dbe1b9207">at</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> idx)</td></tr>
<tr class="memdesc:a4ca0b25404a79967d68fff9dbe1b9207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the element at the specified index with bounds-checking.  <a href="classgul14_1_1SmallVector.html#a4ca0b25404a79967d68fff9dbe1b9207">More...</a><br /></td></tr>
<tr class="separator:a4ca0b25404a79967d68fff9dbe1b9207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b197b09b0fac6b9c4243b89f43ad37f"><td class="memItemLeft" align="right" valign="top"><a id="a7b197b09b0fac6b9c4243b89f43ad37f"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a7b197b09b0fac6b9c4243b89f43ad37f">at</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> idx) const</td></tr>
<tr class="memdesc:a7b197b09b0fac6b9c4243b89f43ad37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the element at the specified index. <br /></td></tr>
<tr class="separator:a7b197b09b0fac6b9c4243b89f43ad37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54954a5e90f6248c5c76a43a25b9e29d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a54954a5e90f6248c5c76a43a25b9e29d">back</a> () noexcept</td></tr>
<tr class="memdesc:a54954a5e90f6248c5c76a43a25b9e29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the last element in the vector.  <a href="classgul14_1_1SmallVector.html#a54954a5e90f6248c5c76a43a25b9e29d">More...</a><br /></td></tr>
<tr class="separator:a54954a5e90f6248c5c76a43a25b9e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a27d99ad99041e00dc6d7cc26ce85f0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a0a27d99ad99041e00dc6d7cc26ce85f0">back</a> () const noexcept</td></tr>
<tr class="memdesc:a0a27d99ad99041e00dc6d7cc26ce85f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in the vector.  <a href="classgul14_1_1SmallVector.html#a0a27d99ad99041e00dc6d7cc26ce85f0">More...</a><br /></td></tr>
<tr class="separator:a0a27d99ad99041e00dc6d7cc26ce85f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c479816cdfa79d400c19b2ba873f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">begin</a> () noexcept</td></tr>
<tr class="memdesc:a206c479816cdfa79d400c19b2ba873f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element of the vector.  <a href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">More...</a><br /></td></tr>
<tr class="separator:a206c479816cdfa79d400c19b2ba873f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe92c3c94b07ba9a268f68f74208e372"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#abe92c3c94b07ba9a268f68f74208e372">begin</a> () const noexcept</td></tr>
<tr class="memdesc:abe92c3c94b07ba9a268f68f74208e372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first element of the vector.  <a href="classgul14_1_1SmallVector.html#abe92c3c94b07ba9a268f68f74208e372">More...</a><br /></td></tr>
<tr class="separator:abe92c3c94b07ba9a268f68f74208e372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c77e200bbb7a5cd53437db5bf9309"><td class="memItemLeft" align="right" valign="top"><a id="a044c77e200bbb7a5cd53437db5bf9309"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a044c77e200bbb7a5cd53437db5bf9309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements that can currently be stored in this vector without having to allocate more memory. <br /></td></tr>
<tr class="separator:a044c77e200bbb7a5cd53437db5bf9309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac653df69ec38aa62495f2472481df602"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ac653df69ec38aa62495f2472481df602">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ac653df69ec38aa62495f2472481df602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first element of the vector.  <a href="classgul14_1_1SmallVector.html#ac653df69ec38aa62495f2472481df602">More...</a><br /></td></tr>
<tr class="separator:ac653df69ec38aa62495f2472481df602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873547dc12fb5e79e6cf87fc3e651b11"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a873547dc12fb5e79e6cf87fc3e651b11">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a873547dc12fb5e79e6cf87fc3e651b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing past the last element of the vector.  <a href="classgul14_1_1SmallVector.html#a873547dc12fb5e79e6cf87fc3e651b11">More...</a><br /></td></tr>
<tr class="separator:a873547dc12fb5e79e6cf87fc3e651b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae835446c7ede9e40dc2f0cea4b63ccbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae835446c7ede9e40dc2f0cea4b63ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all elements from the container without changing its capacity.  <a href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">More...</a><br /></td></tr>
<tr class="separator:ae835446c7ede9e40dc2f0cea4b63ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e7410d66f66f7fb0b6c78f75e62bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ac82e7410d66f66f7fb0b6c78f75e62bc">crbegin</a> () noexcept</td></tr>
<tr class="memdesc:ac82e7410d66f66f7fb0b6c78f75e62bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the first element of the reversed vector (which is the last element of the actual vector).  <a href="classgul14_1_1SmallVector.html#ac82e7410d66f66f7fb0b6c78f75e62bc">More...</a><br /></td></tr>
<tr class="separator:ac82e7410d66f66f7fb0b6c78f75e62bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e77395dbceb2e8ccc83698c5755bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af7e77395dbceb2e8ccc83698c5755bb5">crend</a> () noexcept</td></tr>
<tr class="memdesc:af7e77395dbceb2e8ccc83698c5755bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing past the last element of the reversed vector.  <a href="classgul14_1_1SmallVector.html#af7e77395dbceb2e8ccc83698c5755bb5">More...</a><br /></td></tr>
<tr class="separator:af7e77395dbceb2e8ccc83698c5755bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75111fbfab334a1541aa392fcc59631d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">data</a> () noexcept</td></tr>
<tr class="memdesc:a75111fbfab334a1541aa392fcc59631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the contiguous data storage of the vector.  <a href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">More...</a><br /></td></tr>
<tr class="separator:a75111fbfab334a1541aa392fcc59631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41af1cbae4dc332f02fcac6543e07b37"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a41af1cbae4dc332f02fcac6543e07b37">data</a> () const noexcept</td></tr>
<tr class="memdesc:a41af1cbae4dc332f02fcac6543e07b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the contiguous data storage of the vector.  <a href="classgul14_1_1SmallVector.html#a41af1cbae4dc332f02fcac6543e07b37">More...</a><br /></td></tr>
<tr class="separator:a41af1cbae4dc332f02fcac6543e07b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd425083c3df94d26a443c3b03cbf70"><td class="memTemplParams" colspan="2">template&lt;typename... ArgumentTypes&gt; </td></tr>
<tr class="memitem:a6cd425083c3df94d26a443c3b03cbf70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70">emplace</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, ArgumentTypes &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:a6cd425083c3df94d26a443c3b03cbf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an additional element at an arbitrary position in the vector.  <a href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70">More...</a><br /></td></tr>
<tr class="separator:a6cd425083c3df94d26a443c3b03cbf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b27a9ffc18200bf81d4747795b5180"><td class="memTemplParams" colspan="2">template&lt;typename... ArgumentTypes&gt; </td></tr>
<tr class="memitem:a25b27a9ffc18200bf81d4747795b5180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180">emplace_back</a> (ArgumentTypes &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:a25b27a9ffc18200bf81d4747795b5180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an additional element at the end of the buffer.  <a href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180">More...</a><br /></td></tr>
<tr class="separator:a25b27a9ffc18200bf81d4747795b5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85874f791bb5b3554697d77accfcbf69"><td class="memItemLeft" align="right" valign="top"><a id="a85874f791bb5b3554697d77accfcbf69"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a85874f791bb5b3554697d77accfcbf69">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a85874f791bb5b3554697d77accfcbf69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the vector is empty. <br /></td></tr>
<tr class="separator:a85874f791bb5b3554697d77accfcbf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf2675cf182429b10c49377f917e5a2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">end</a> () noexcept</td></tr>
<tr class="memdesc:a7bf2675cf182429b10c49377f917e5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing past the last element of the vector.  <a href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">More...</a><br /></td></tr>
<tr class="separator:a7bf2675cf182429b10c49377f917e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3ed502879ba32fa611b1b719cbaea1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#abb3ed502879ba32fa611b1b719cbaea1">end</a> () const noexcept</td></tr>
<tr class="memdesc:abb3ed502879ba32fa611b1b719cbaea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing past the last element of the vector.  <a href="classgul14_1_1SmallVector.html#abb3ed502879ba32fa611b1b719cbaea1">More...</a><br /></td></tr>
<tr class="separator:abb3ed502879ba32fa611b1b719cbaea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c77321c8609dd58d793ca16ab1d1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a10c77321c8609dd58d793ca16ab1d1e4">erase</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos)</td></tr>
<tr class="memdesc:a10c77321c8609dd58d793ca16ab1d1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a single element from the vector, moving elements behind it forward.  <a href="classgul14_1_1SmallVector.html#a10c77321c8609dd58d793ca16ab1d1e4">More...</a><br /></td></tr>
<tr class="separator:a10c77321c8609dd58d793ca16ab1d1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd1e01c26dd90503888a541b7d2ad62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6bd1e01c26dd90503888a541b7d2ad62">erase</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> first, <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> last)</td></tr>
<tr class="memdesc:a6bd1e01c26dd90503888a541b7d2ad62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements from the vector, moving elements behind the range forward.  <a href="classgul14_1_1SmallVector.html#a6bd1e01c26dd90503888a541b7d2ad62">More...</a><br /></td></tr>
<tr class="separator:a6bd1e01c26dd90503888a541b7d2ad62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3cd309f9f12f9724d52a9efd7c7915"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aed3cd309f9f12f9724d52a9efd7c7915">front</a> () noexcept</td></tr>
<tr class="memdesc:aed3cd309f9f12f9724d52a9efd7c7915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first element in the vector.  <a href="classgul14_1_1SmallVector.html#aed3cd309f9f12f9724d52a9efd7c7915">More...</a><br /></td></tr>
<tr class="separator:aed3cd309f9f12f9724d52a9efd7c7915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141b6175273287f55c5a66c6fe46d58c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a141b6175273287f55c5a66c6fe46d58c">front</a> () const noexcept</td></tr>
<tr class="memdesc:a141b6175273287f55c5a66c6fe46d58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in the vector.  <a href="classgul14_1_1SmallVector.html#a141b6175273287f55c5a66c6fe46d58c">More...</a><br /></td></tr>
<tr class="separator:a141b6175273287f55c5a66c6fe46d58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90eed50ef66c1960f978b240353163c"><td class="memItemLeft" align="right" valign="top"><a id="aa90eed50ef66c1960f978b240353163c"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aa90eed50ef66c1960f978b240353163c">inner_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aa90eed50ef66c1960f978b240353163c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> can hold internally without having to allocate storage. <br /></td></tr>
<tr class="separator:aa90eed50ef66c1960f978b240353163c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a70ad212b2d653e5fc08832d6acea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a88a70ad212b2d653e5fc08832d6acea6">insert</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a88a70ad212b2d653e5fc08832d6acea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single element before the indicated position.  <a href="classgul14_1_1SmallVector.html#a88a70ad212b2d653e5fc08832d6acea6">More...</a><br /></td></tr>
<tr class="separator:a88a70ad212b2d653e5fc08832d6acea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d46c8ca495b892e6884607b1f25a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ad1d46c8ca495b892e6884607b1f25a6f">insert</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ad1d46c8ca495b892e6884607b1f25a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single element before the indicated position.  <a href="classgul14_1_1SmallVector.html#ad1d46c8ca495b892e6884607b1f25a6f">More...</a><br /></td></tr>
<tr class="separator:ad1d46c8ca495b892e6884607b1f25a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfaeb533db143ae2ae2ff5005f7b049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a2cfaeb533db143ae2ae2ff5005f7b049">insert</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements, const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a2cfaeb533db143ae2ae2ff5005f7b049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a number of copies of the given value before the indicated position.  <a href="classgul14_1_1SmallVector.html#a2cfaeb533db143ae2ae2ff5005f7b049">More...</a><br /></td></tr>
<tr class="separator:a2cfaeb533db143ae2ae2ff5005f7b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd84e8f4d93bf5eb62bf8cf903db75"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4fdd84e8f4d93bf5eb62bf8cf903db75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a4fdd84e8f4d93bf5eb62bf8cf903db75">insert</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a4fdd84e8f4d93bf5eb62bf8cf903db75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range of values before the indicated position.  <a href="classgul14_1_1SmallVector.html#a4fdd84e8f4d93bf5eb62bf8cf903db75">More...</a><br /></td></tr>
<tr class="separator:a4fdd84e8f4d93bf5eb62bf8cf903db75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6fb189060f149c88b077b28969d0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a5b6fb189060f149c88b077b28969d0b3">insert</a> (<a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> pos, std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt; init)</td></tr>
<tr class="memdesc:a5b6fb189060f149c88b077b28969d0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements from an initializer list before the indicated position.  <a href="classgul14_1_1SmallVector.html#a5b6fb189060f149c88b077b28969d0b3">More...</a><br /></td></tr>
<tr class="separator:a5b6fb189060f149c88b077b28969d0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c17d8d1021aa156c8fcae523edb4fb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a57c17d8d1021aa156c8fcae523edb4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements that this vector can theoretically hold.  <a href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb">More...</a><br /></td></tr>
<tr class="separator:a57c17d8d1021aa156c8fcae523edb4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1342d558261623a6109371a90ceda2e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4">operator=</a> (const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;other) noexcept(std::is_nothrow_copy_assignable&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;::value)</td></tr>
<tr class="memdesc:a1342d558261623a6109371a90ceda2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: Copy all elements from another <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> after clearing all previous contents.  <a href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4">More...</a><br /></td></tr>
<tr class="separator:a1342d558261623a6109371a90ceda2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa2646f94d9beefbf094f5839bf78cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a0aa2646f94d9beefbf094f5839bf78cc">operator=</a> (<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;&amp;other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;::value)</td></tr>
<tr class="memdesc:a0aa2646f94d9beefbf094f5839bf78cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator: Assign all of the elements from another vector to this one using move semantics after clearing all previous contents.  <a href="classgul14_1_1SmallVector.html#a0aa2646f94d9beefbf094f5839bf78cc">More...</a><br /></td></tr>
<tr class="separator:a0aa2646f94d9beefbf094f5839bf78cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c745720e2a690aecd2415907148613"><td class="memItemLeft" align="right" valign="top"><a id="a39c745720e2a690aecd2415907148613"></a>
<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a39c745720e2a690aecd2415907148613">operator=</a> (std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt; init)</td></tr>
<tr class="memdesc:a39c745720e2a690aecd2415907148613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the elements of an initializer list to this vector after clearing all previous contents. <br /></td></tr>
<tr class="separator:a39c745720e2a690aecd2415907148613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722acdb89c05d9caa14ddfac567555d"><td class="memItemLeft" align="right" valign="top"><a id="ae722acdb89c05d9caa14ddfac567555d"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ae722acdb89c05d9caa14ddfac567555d">operator[]</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> idx)</td></tr>
<tr class="memdesc:ae722acdb89c05d9caa14ddfac567555d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the element at the specified index. <br /></td></tr>
<tr class="separator:ae722acdb89c05d9caa14ddfac567555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b3fa354c14b453754e05c4999c9f0"><td class="memItemLeft" align="right" valign="top"><a id="af01b3fa354c14b453754e05c4999c9f0"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af01b3fa354c14b453754e05c4999c9f0">operator[]</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> idx) const</td></tr>
<tr class="memdesc:af01b3fa354c14b453754e05c4999c9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the element at the specified index. <br /></td></tr>
<tr class="separator:af01b3fa354c14b453754e05c4999c9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aa01cac20ad5a59cb79064af614d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a34aa01cac20ad5a59cb79064af614d48">pop_back</a> ()</td></tr>
<tr class="memdesc:a34aa01cac20ad5a59cb79064af614d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from the vector.  <a href="classgul14_1_1SmallVector.html#a34aa01cac20ad5a59cb79064af614d48">More...</a><br /></td></tr>
<tr class="separator:a34aa01cac20ad5a59cb79064af614d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e015b0e0da2198597503ccfa69f92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#af8e015b0e0da2198597503ccfa69f92b">push_back</a> (const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:af8e015b0e0da2198597503ccfa69f92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one element to the end of the buffer.  <a href="classgul14_1_1SmallVector.html#af8e015b0e0da2198597503ccfa69f92b">More...</a><br /></td></tr>
<tr class="separator:af8e015b0e0da2198597503ccfa69f92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b231cc722f49a114f1a1dd4427a3b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ac0b231cc722f49a114f1a1dd4427a3b3">push_back</a> (<a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ac0b231cc722f49a114f1a1dd4427a3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move one element to the end of the buffer.  <a href="classgul14_1_1SmallVector.html#ac0b231cc722f49a114f1a1dd4427a3b3">More...</a><br /></td></tr>
<tr class="separator:ac0b231cc722f49a114f1a1dd4427a3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d2ed4feae2aa55f90357c259671201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a15d2ed4feae2aa55f90357c259671201">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a15d2ed4feae2aa55f90357c259671201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the first element of the reversed vector (which is the last element of the actual vector).  <a href="classgul14_1_1SmallVector.html#a15d2ed4feae2aa55f90357c259671201">More...</a><br /></td></tr>
<tr class="separator:a15d2ed4feae2aa55f90357c259671201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac818e47b8b7f85df461ed16d924570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6ac818e47b8b7f85df461ed16d924570">rend</a> () noexcept</td></tr>
<tr class="memdesc:a6ac818e47b8b7f85df461ed16d924570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator pointing past the last element of the reversed vector.  <a href="classgul14_1_1SmallVector.html#a6ac818e47b8b7f85df461ed16d924570">More...</a><br /></td></tr>
<tr class="separator:a6ac818e47b8b7f85df461ed16d924570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634a091f8cb3e1fccb3b02c497d26924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">reserve</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> new_capacity)</td></tr>
<tr class="memdesc:a634a091f8cb3e1fccb3b02c497d26924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the vector to the specified size.  <a href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">More...</a><br /></td></tr>
<tr class="separator:a634a091f8cb3e1fccb3b02c497d26924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0e2ee783a74b90f9864cc9f9543781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781">resize</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements)</td></tr>
<tr class="memdesc:a1d0e2ee783a74b90f9864cc9f9543781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of elements in the container.  <a href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781">More...</a><br /></td></tr>
<tr class="separator:a1d0e2ee783a74b90f9864cc9f9543781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44053f66c8700034cf7905a8ecd868d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#aa44053f66c8700034cf7905a8ecd868d">resize</a> (<a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> num_elements, const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;element)</td></tr>
<tr class="memdesc:aa44053f66c8700034cf7905a8ecd868d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of elements in the container.  <a href="classgul14_1_1SmallVector.html#aa44053f66c8700034cf7905a8ecd868d">More...</a><br /></td></tr>
<tr class="separator:aa44053f66c8700034cf7905a8ecd868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bc0e29dcd54fca0321322389b2a6f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#ab7bc0e29dcd54fca0321322389b2a6f7">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ab7bc0e29dcd54fca0321322389b2a6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the capacity as far as possible while retaining all stored elements.  <a href="classgul14_1_1SmallVector.html#ab7bc0e29dcd54fca0321322389b2a6f7">More...</a><br /></td></tr>
<tr class="separator:ab7bc0e29dcd54fca0321322389b2a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e79bb273d6dc1bb4ecb90405ed957"><td class="memItemLeft" align="right" valign="top"><a id="afa8e79bb273d6dc1bb4ecb90405ed957"></a>
constexpr <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957">size</a> () const noexcept</td></tr>
<tr class="memdesc:afa8e79bb273d6dc1bb4ecb90405ed957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements that are currently stored. <br /></td></tr>
<tr class="separator:afa8e79bb273d6dc1bb4ecb90405ed957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0fa47638f2ad8e70172fa71fcbd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a6ac0fa47638f2ad8e70172fa71fcbd77">swap</a> (<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;other)</td></tr>
<tr class="memdesc:a6ac0fa47638f2ad8e70172fa71fcbd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the contents of this <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one.  <a href="classgul14_1_1SmallVector.html#a6ac0fa47638f2ad8e70172fa71fcbd77">More...</a><br /></td></tr>
<tr class="separator:a6ac0fa47638f2ad8e70172fa71fcbd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a556093ed0d8700acfa03836278ee1638"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a556093ed0d8700acfa03836278ee1638">operator==</a> (const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;lhs, const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a556093ed0d8700acfa03836278ee1638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator: Return true if both vectors have the same <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> and the same elements.  <a href="classgul14_1_1SmallVector.html#a556093ed0d8700acfa03836278ee1638">More...</a><br /></td></tr>
<tr class="separator:a556093ed0d8700acfa03836278ee1638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16efde1ad04ee2e65d30506dfd7aacc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgul14_1_1SmallVector.html#a16efde1ad04ee2e65d30506dfd7aacc0">operator!=</a> (const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;lhs, const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a16efde1ad04ee2e65d30506dfd7aacc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator: Return true if both vectors have a different <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> or at least one different element.  <a href="classgul14_1_1SmallVector.html#a16efde1ad04ee2e65d30506dfd7aacc0">More...</a><br /></td></tr>
<tr class="separator:a16efde1ad04ee2e65d30506dfd7aacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a72d363425fbe5e551547d76116e6a318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d363425fbe5e551547d76116e6a318">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a72d363425fbe5e551547d76116e6a318">const_iterator</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator to a const element. </p>

</div>
</div>
<a id="a89449b60742cb7ed9cff3912ba07e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89449b60742cb7ed9cff3912ba07e6f5">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a89449b60742cb7ed9cff3912ba07e6f5">const_reference</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to a const element. </p>

</div>
</div>
<a id="af31269c1d7c63fc9f2f26e5b2ce4f566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31269c1d7c63fc9f2f26e5b2ce4f566">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#af31269c1d7c63fc9f2f26e5b2ce4f566">const_reverse_iterator</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator to a const element in reversed container. </p>

</div>
</div>
<a id="a6e92eb526722ba60bbffacc1d11db276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e92eb526722ba60bbffacc1d11db276">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a6e92eb526722ba60bbffacc1d11db276">difference_type</a> =  <a class="el" href="classgul14_1_1SmallVector.html#af109141bbfb4a1e1079d8d925e6ad25a">DifferenceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type for the difference of two iterators. </p>

</div>
</div>
<a id="a0a7d96f0979a0096999c3965cd2a8a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7d96f0979a0096999c3965cd2a8a88">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a0a7d96f0979a0096999c3965cd2a8a88">iterator</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator to an element. </p>

</div>
</div>
<a id="aad1d72d4276793826e01422cd3e5d0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1d72d4276793826e01422cd3e5d0c7">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#aad1d72d4276793826e01422cd3e5d0c7">reference</a> =  <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to an element. </p>

</div>
</div>
<a id="a3310e4d386a343beade052e2be0ad29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3310e4d386a343beade052e2be0ad29b">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a3310e4d386a343beade052e2be0ad29b">reverse_iterator</a> =  <a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator to an element in reversed container. </p>

</div>
</div>
<a id="a7e03ad8b3216b23912296b6d8a0d7cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e03ad8b3216b23912296b6d8a0d7cca">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a7e03ad8b3216b23912296b6d8a0d7cca">size_type</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type for indexing, number of elements, capacity. </p>

</div>
</div>
<a id="a8764c49ed633f9d63221c1f4b3968ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8764c49ed633f9d63221c1f4b3968ec7">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html#a8764c49ed633f9d63221c1f4b3968ec7">value_type</a> =  <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the elements in the underlying container. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a7d45b5344dd40cf90b84ac22bd9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7d45b5344dd40cf90b84ac22bd9393">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a>. </p>
<p>If the template argument is zero, a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> based on std::vector with a capacity of zero elements is generated. Use the <a class="el" href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571">SmallVector(size_type)</a> constructor or call the <a class="el" href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781" title="Change the number of elements in the container.">resize()</a> function afterwards to get a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> based on std::vector with nonzero capacity. </p>

</div>
</div>
<a id="a79e006aadaf59912c25a0a0be4e59571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e006aadaf59912c25a0a0be4e59571">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of default-initialized elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>The number of initial elements </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>.</p>

</div>
</div>
<a id="a9d5deabac040e12fa5af89195617c426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5deabac040e12fa5af89195617c426">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with a certain number of copies of the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>The number of initial elements </td></tr>
    <tr><td class="paramname">value</td><td>The value to be copied to the initial elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa22f275b8ef1077f144ab524b01b2b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22f275b8ef1077f144ab524b01b2b6a">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with copies of elements from the given range. </p>
<p>This constructor is not available if the iterators are of integral (and non-pointer) type, in order to avoid confusion with <a class="el" href="classgul14_1_1SmallVector.html#a9d5deabac040e12fa5af89195617c426" title="Construct a SmallVector that is filled with a certain number of copies of the given value.">SmallVector(SizeType num_elements, const ValueType&amp; value)</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>An input iterator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element to be copied </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the number of input elements exceeds <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

</div>
</div>
<a id="afea05971fb194b17366d056ba7a37990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea05971fb194b17366d056ba7a37990">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of another <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with the same inner capacity. </p>
<p>The new vector is filled with copies of the original data elements. It has the same <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> as the original, but its <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a> might differ.</p>
<dl class="section note"><dt>Note</dt><dd>The copy constructor cannot be used if the element type itself is not copyable. </dd></dl>

</div>
</div>
<a id="af743bb3649edfa476b380053bd5bbc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af743bb3649edfa476b380053bd5bbc9f">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor: Create a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> from the contents of another one with the same inner capacity using move semantics. </p>
<p>The new vector has the same <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> as the original, but its <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a> might differ. The original vector is <a class="el" href="classgul14_1_1SmallVector.html#a85874f791bb5b3554697d77accfcbf69" title="Determine if the vector is empty.">empty()</a> after the operation.</p>
<p>If the other vector has allocated storage, it is efficiently moved in en-bloc. If it uses the internal storage, the behavior depends on the availability of a non-throwing move constructor. If such a <code>noexcept</code> move constructor is available, elements are moved in one-by-one. Otherwise, elements are copied in.</p>
<p>If no exception is thrown, the other vector is guaranteed to be empty after the call. If an exception is thrown, it is guaranteed to be unchanged if ValueType is either copy-constructible or nothrow-move-constructible. </p>

</div>
</div>
<a id="ab4c5473cacc32dcffbe8a30595e671f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c5473cacc32dcffbe8a30595e671f6">&#9670;&nbsp;</a></span>SmallVector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::<a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> that is filled with copies of the elements from a given initializer list. </p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the number of elements in the initializer list exceeds <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adbb09ec0e11af004813764070e08670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb09ec0e11af004813764070e08670f">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the vector with copies of elements from the given range. </p>
<p>This overload is not available if the iterators are of integral (and non-pointer) type, in order to avoid confusion with <a class="el" href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39" title="Fill the vector with a certain number of copies of the given value after clearing all previous conten...">assign(SizeType num_elements, const ValueType&amp; value)</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>An input iterator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element to be copied </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the corresponding function from <code>std::vector</code>, <code><a class="el" href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39" title="Fill the vector with a certain number of copies of the given value after clearing all previous conten...">SmallVector::assign()</a></code> does not allow narrowing conversions.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the number of input elements exceeds <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>.</p>

</div>
</div>
<a id="a5373fc10db415ce3f15c51f9b7196a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5373fc10db415ce3f15c51f9b7196a39">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the vector with a certain number of copies of the given value after clearing all previous contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>The number of initial elements </td></tr>
    <tr><td class="paramname">value</td><td>The value to be copied into the vector </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a39c745720e2a690aecd2415907148613">gul14::SmallVector&lt; ElementT, in_capacity &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a74a23a2543f50d0fc3148e2847db76e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a23a2543f50d0fc3148e2847db76e0">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the elements of an initializer list to this vector after clearing all previous contents. </p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the number of elements in the initializer list exceeds <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>.</p>

</div>
</div>
<a id="a4ca0b25404a79967d68fff9dbe1b9207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca0b25404a79967d68fff9dbe1b9207">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the element at the specified index with bounds-checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>is thrown if idx &gt;= <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__cat__h.html#gad64e01233c1c469a698c36c9e2f89079">gul14::cat()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

</div>
</div>
<a id="a0a27d99ad99041e00dc6d7cc26ce85f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a27d99ad99041e00dc6d7cc26ce85f0">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in the vector. </p>
<p>The behavior is undefined if the vector is empty. </p>

</div>
</div>
<a id="a54954a5e90f6248c5c76a43a25b9e29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54954a5e90f6248c5c76a43a25b9e29d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the last element in the vector. </p>
<p>The behavior is undefined if the vector is empty. </p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180">gul14::SmallVector&lt; ElementT, in_capacity &gt;::emplace_back()</a>.</p>

</div>
</div>
<a id="abe92c3c94b07ba9a268f68f74208e372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe92c3c94b07ba9a268f68f74208e372">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first element of the vector. </p>
<p>If the vector is empty, this iterator cannot be dereferenced. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

</div>
</div>
<a id="a206c479816cdfa79d400c19b2ba873f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206c479816cdfa79d400c19b2ba873f1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element of the vector. </p>
<p>If the vector is empty, this iterator cannot be dereferenced. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#ac653df69ec38aa62495f2472481df602">gul14::SmallVector&lt; ElementT, in_capacity &gt;::cbegin()</a>, <a class="el" href="classgul14_1_1SmallVector.html#af7e77395dbceb2e8ccc83698c5755bb5">gul14::SmallVector&lt; ElementT, in_capacity &gt;::crend()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a2cfaeb533db143ae2ae2ff5005f7b049">gul14::SmallVector&lt; ElementT, in_capacity &gt;::insert()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a6ac818e47b8b7f85df461ed16d924570">gul14::SmallVector&lt; ElementT, in_capacity &gt;::rend()</a>.</p>

</div>
</div>
<a id="ac653df69ec38aa62495f2472481df602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac653df69ec38aa62495f2472481df602">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first element of the vector. </p>
<p>If the vector is empty, this iterator cannot be dereferenced. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>.</p>

</div>
</div>
<a id="a873547dc12fb5e79e6cf87fc3e651b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873547dc12fb5e79e6cf87fc3e651b11">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing past the last element of the vector. </p>
<p>This iterator cannot be dereferenced. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">gul14::SmallVector&lt; ElementT, in_capacity &gt;::end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70">gul14::SmallVector&lt; ElementT, in_capacity &gt;::emplace()</a>.</p>

</div>
</div>
<a id="ae835446c7ede9e40dc2f0cea4b63ccbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae835446c7ede9e40dc2f0cea4b63ccbc">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all elements from the container without changing its capacity. </p>
<p>The <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> is zero after this call. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a5373fc10db415ce3f15c51f9b7196a39">gul14::SmallVector&lt; ElementT, in_capacity &gt;::assign()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4">gul14::SmallVector&lt; ElementT, in_capacity &gt;::operator=()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a6476df76f72bf67afbea23803075be46">gul14::SmallVector&lt; ElementT, in_capacity &gt;::~SmallVector()</a>.</p>

</div>
</div>
<a id="ac82e7410d66f66f7fb0b6c78f75e62bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82e7410d66f66f7fb0b6c78f75e62bc">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the first element of the reversed vector (which is the last element of the actual vector). </p>
<p>The iterator cannot be dereferenced if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">gul14::SmallVector&lt; ElementT, in_capacity &gt;::end()</a>.</p>

</div>
</div>
<a id="af7e77395dbceb2e8ccc83698c5755bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e77395dbceb2e8ccc83698c5755bb5">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a951844dc268183f7f2cba2a9c643e9fd">ConstReverseIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing past the last element of the reversed vector. </p>
<p>The iterator cannot be dereferenced if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>.</p>

</div>
</div>
<a id="a41af1cbae4dc332f02fcac6543e07b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41af1cbae4dc332f02fcac6543e07b37">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a>* <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the contiguous data storage of the vector. </p>
<p>If the vector is empty, the pointer is not dereferencable. </p>

</div>
</div>
<a id="a75111fbfab334a1541aa392fcc59631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75111fbfab334a1541aa392fcc59631d">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a>* <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the contiguous data storage of the vector. </p>
<p>If the vector is empty, the pointer is not dereferencable. </p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a74a23a2543f50d0fc3148e2847db76e0">gul14::SmallVector&lt; ElementT, in_capacity &gt;::assign()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a4ca0b25404a79967d68fff9dbe1b9207">gul14::SmallVector&lt; ElementT, in_capacity &gt;::at()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>, <a class="el" href="classgul14_1_1SmallVector.html#aed3cd309f9f12f9724d52a9efd7c7915">gul14::SmallVector&lt; ElementT, in_capacity &gt;::front()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4">gul14::SmallVector&lt; ElementT, in_capacity &gt;::operator=()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ae722acdb89c05d9caa14ddfac567555d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::operator[]()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781">gul14::SmallVector&lt; ElementT, in_capacity &gt;::resize()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ab7bc0e29dcd54fca0321322389b2a6f7">gul14::SmallVector&lt; ElementT, in_capacity &gt;::shrink_to_fit()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571">gul14::SmallVector&lt; ElementT, in_capacity &gt;::SmallVector()</a>.</p>

</div>
</div>
<a id="a6cd425083c3df94d26a443c3b03cbf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd425083c3df94d26a443c3b03cbf70">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<div class="memtemplate">
template&lt;typename... ArgumentTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgumentTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an additional element at an arbitrary position in the vector. </p>
<p>The new element is inserted at the position indicated by pos; pre-existing elements at and after this position are moved backwards. Other parameters of <a class="el" href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70" title="Construct an additional element at an arbitrary position in the vector.">emplace()</a> are passed to the element constructor via perfect forwarding.</p>
<p>If pos == <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a>, the new element is constructed in-place at the end of the vector. Otherwise, it is first constructed on the stack and then move-assigned into the vector. If the constructor of the new element throws, the contents of the vector are not changed, but the capacity might differ.</p>
<p>All existing iterators are invalidated if the new <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> exceeds the original <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a>. Otherwise, only the iterators to elements at or after pos are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Constant iterator to the position at which the new element should be constructed. </td></tr>
    <tr><td class="paramname">arguments</td><td>List of arguments for the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the new element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>is thrown if the maximum capacity of the container is reached and cannot be increased. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a873547dc12fb5e79e6cf87fc3e651b11">gul14::SmallVector&lt; ElementT, in_capacity &gt;::cend()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180">gul14::SmallVector&lt; ElementT, in_capacity &gt;::emplace_back()</a>.</p>

</div>
</div>
<a id="a25b27a9ffc18200bf81d4747795b5180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b27a9ffc18200bf81d4747795b5180">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<div class="memtemplate">
template&lt;typename... ArgumentTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">ArgumentTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an additional element at the end of the buffer. </p>
<p>The parameters of <a class="el" href="classgul14_1_1SmallVector.html#a25b27a9ffc18200bf81d4747795b5180" title="Construct an additional element at the end of the buffer.">emplace_back()</a> are passed to the element constructor via perfect forwarding. If the constructor of the new element throws, the contents of the vector are not changed, but the capacity might differ.</p>
<p>All existing iterators are invalidated if the new <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> exceeds the original <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a>. Otherwise, only the <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a> iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>List of arguments for the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the new element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>is thrown if the maximum capacity of the container is reached and cannot be increased. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a54954a5e90f6248c5c76a43a25b9e29d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a6cd425083c3df94d26a443c3b03cbf70">gul14::SmallVector&lt; ElementT, in_capacity &gt;::emplace()</a>.</p>

</div>
</div>
<a id="abb3ed502879ba32fa611b1b719cbaea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3ed502879ba32fa611b1b719cbaea1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing past the last element of the vector. </p>
<p>This iterator cannot be dereferenced. </p>

</div>
</div>
<a id="a7bf2675cf182429b10c49377f917e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf2675cf182429b10c49377f917e5a2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator pointing past the last element of the vector. </p>
<p>This iterator cannot be dereferenced. </p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a873547dc12fb5e79e6cf87fc3e651b11">gul14::SmallVector&lt; ElementT, in_capacity &gt;::cend()</a>, <a class="el" href="classgul14_1_1SmallVector.html#ac82e7410d66f66f7fb0b6c78f75e62bc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::crbegin()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a6bd1e01c26dd90503888a541b7d2ad62">gul14::SmallVector&lt; ElementT, in_capacity &gt;::erase()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a15d2ed4feae2aa55f90357c259671201">gul14::SmallVector&lt; ElementT, in_capacity &gt;::rbegin()</a>.</p>

</div>
</div>
<a id="a6bd1e01c26dd90503888a541b7d2ad62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd1e01c26dd90503888a541b7d2ad62">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of elements from the vector, moving elements behind the range forward. </p>
<p>This call does not change the capacity. Iterators pointing at or after the deleted range are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the element following the last erased one or <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a> if elements at the end of the vector were deleted. If the range to be erased was empty, <code>last</code> is returned. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">gul14::SmallVector&lt; ElementT, in_capacity &gt;::end()</a>.</p>

</div>
</div>
<a id="a10c77321c8609dd58d793ca16ab1d1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c77321c8609dd58d793ca16ab1d1e4">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a single element from the vector, moving elements behind it forward. </p>
<p>This call does not change the capacity. Iterators pointing at or after the deleted element are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. This iterator must be dereferenceable, so <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a> is not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the element following the erased one or <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a> if the element at the end of the vector was deleted. </dd></dl>

</div>
</div>
<a id="a141b6175273287f55c5a66c6fe46d58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141b6175273287f55c5a66c6fe46d58c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a4fb0d9cf9e1551b71c6b171b47daa40d">ConstReference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in the vector. </p>
<p>The behavior is undefined if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

</div>
</div>
<a id="aed3cd309f9f12f9724d52a9efd7c7915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3cd309f9f12f9724d52a9efd7c7915">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#aa6deadff25be00e7f058cf651837f256">Reference</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the first element in the vector. </p>
<p>The behavior is undefined if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

</div>
</div>
<a id="a88a70ad212b2d653e5fc08832d6acea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a70ad212b2d653e5fc08832d6acea6">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a single element before the indicated position. </p>
<p>This increases the size of the container by 1. All elements starting from the indicated position are moved backwards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the existing element in front of which the new value should be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be copied into the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the newly inserted element. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a5b6fb189060f149c88b077b28969d0b3">gul14::SmallVector&lt; ElementT, in_capacity &gt;::insert()</a>.</p>

</div>
</div>
<a id="a4fdd84e8f4d93bf5eb62bf8cf903db75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdd84e8f4d93bf5eb62bf8cf903db75">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::enable_if_t&lt;not std::is_integral&lt;InputIterator&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range of values before the indicated position. </p>
<p>This overload is not available if the iterators are of integral (and non-pointer) type, in order to avoid confusion with <a class="el" href="classgul14_1_1SmallVector.html#a2cfaeb533db143ae2ae2ff5005f7b049" title="Insert a number of copies of the given value before the indicated position.">insert(ConstIterator pos, SizeType num_elements, const ValueType&amp; value)</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>An input iterator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the existing element in front of which the new values should be inserted. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element to be copied. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing past the last element to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first of the inserted elements or pos if the range is empty.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the total number of elements after insertion would exceed <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>.</p>

</div>
</div>
<a id="a2cfaeb533db143ae2ae2ff5005f7b049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfaeb533db143ae2ae2ff5005f7b049">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a number of copies of the given value before the indicated position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the existing element in front of which the new value should be inserted. </td></tr>
    <tr><td class="paramname">num_elements</td><td>The number of elements to be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be moved into the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first of the inserted elements or pos if num_elements == 0. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>.</p>

</div>
</div>
<a id="a5b6fb189060f149c88b077b28969d0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6fb189060f149c88b077b28969d0b3">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements from an initializer list before the indicated position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the existing element in front of which the new values should be inserted. </td></tr>
    <tr><td class="paramname">init</td><td>An initializer list with the values to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the first of the inserted elements or pos if the range is empty.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the total number of elements after insertion would exceed <a class="el" href="classgul14_1_1SmallVector.html#a57c17d8d1021aa156c8fcae523edb4fb" title="Return the maximum number of elements that this vector can theoretically hold.">max_size()</a>. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a88a70ad212b2d653e5fc08832d6acea6">gul14::SmallVector&lt; ElementT, in_capacity &gt;::insert()</a>.</p>

</div>
</div>
<a id="ad1d46c8ca495b892e6884607b1f25a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d46c8ca495b892e6884607b1f25a6f">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#a6a736e2f7bd751de4e51e7944c422ea0">Iterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a98e6fd265c462692df44454c3774a544">ConstIterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a single element before the indicated position. </p>
<p>This increases the size of the container by 1. All elements starting from the indicated position are moved backwards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the existing element in front of which the new value should be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be moved into the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator to the newly inserted element. </dd></dl>

</div>
</div>
<a id="a57c17d8d1021aa156c8fcae523edb4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c17d8d1021aa156c8fcae523edb4fb">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements that this vector can theoretically hold. </p>
<p>This value reflects only limitations of the implementation. It is possible that the size of the container is effectively limited to a much smaller value because of limited available memory. </p>

</div>
</div>
<a id="a1342d558261623a6109371a90ceda2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1342d558261623a6109371a90ceda2e4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&amp; <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: Copy all elements from another <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> after clearing all previous contents. </p>
<dl class="section note"><dt>Note</dt><dd>Copy assignment is only possible if the element type itself is copyable. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>.</p>

</div>
</div>
<a id="a0aa2646f94d9beefbf094f5839bf78cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa2646f94d9beefbf094f5839bf78cc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&amp; <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator: Assign all of the elements from another vector to this one using move semantics after clearing all previous contents. </p>
<p>If the other vector has allocated storage, it is efficiently moved in en-bloc. If it uses the internal storage, the behavior depends on the availability of a non-throwing move constructor. If such a <code>noexcept</code> move constructor is available, elements are moved in one-by-one. Otherwise, elements are copied in.</p>
<p>If no exception is thrown, the other vector is guaranteed to be empty after the call. If an exception is thrown, it is guaranteed to be unchanged if ValueType is either copy-constructible or nothrow-move-constructible. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#ae835446c7ede9e40dc2f0cea4b63ccbc">gul14::SmallVector&lt; ElementT, in_capacity &gt;::clear()</a>.</p>

</div>
</div>
<a id="a34aa01cac20ad5a59cb79064af614d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aa01cac20ad5a59cb79064af614d48">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from the vector. </p>
<p>Calling <a class="el" href="classgul14_1_1SmallVector.html#a34aa01cac20ad5a59cb79064af614d48" title="Remove the last element from the vector.">pop_back()</a> on an empty vector results in undefined behavior. </p>

</div>
</div>
<a id="af8e015b0e0da2198597503ccfa69f92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e015b0e0da2198597503ccfa69f92b">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy one element to the end of the buffer. </p>
<p>All existing iterators are invalidated if the new <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> exceeds the original <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a>. Otherwise, only the <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2" title="Return an iterator pointing past the last element of the vector.">end()</a> iterator is invalidated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>is thrown if the maximum capacity of the container is reached and cannot be increased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b231cc722f49a114f1a1dd4427a3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b231cc722f49a114f1a1dd4427a3b3">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move one element to the end of the buffer. </p>
<p>This invalidates all existing iterators.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>is thrown if the maximum capacity of the container is reached and cannot be increased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d2ed4feae2aa55f90357c259671201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d2ed4feae2aa55f90357c259671201">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reverse iterator to the first element of the reversed vector (which is the last element of the actual vector). </p>
<p>The iterator cannot be dereferenced if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a7bf2675cf182429b10c49377f917e5a2">gul14::SmallVector&lt; ElementT, in_capacity &gt;::end()</a>.</p>

</div>
</div>
<a id="a6ac818e47b8b7f85df461ed16d924570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac818e47b8b7f85df461ed16d924570">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgul14_1_1SmallVector.html#ad609da079115c0ec6f559ceb945770db">ReverseIterator</a> <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reverse iterator pointing past the last element of the reversed vector. </p>
<p>The iterator cannot be dereferenced if the vector is empty. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a206c479816cdfa79d400c19b2ba873f1">gul14::SmallVector&lt; ElementT, in_capacity &gt;::begin()</a>.</p>

</div>
</div>
<a id="a634a091f8cb3e1fccb3b02c497d26924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634a091f8cb3e1fccb3b02c497d26924">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the vector to the specified size. </p>
<p>This call can only enlarge the container. If new_capacity &lt; <a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a>, the call does nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>The new capacity of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgul14_1_1SmallVector.html#ab7bc0e29dcd54fca0321322389b2a6f7" title="Reduce the capacity as far as possible while retaining all stored elements.">shrink_to_fit()</a> can be used to shrink the vector </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgul14_1_1SmallVector.html#a74a23a2543f50d0fc3148e2847db76e0">gul14::SmallVector&lt; ElementT, in_capacity &gt;::assign()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a1342d558261623a6109371a90ceda2e4">gul14::SmallVector&lt; ElementT, in_capacity &gt;::operator=()</a>, <a class="el" href="classgul14_1_1SmallVector.html#a1d0e2ee783a74b90f9864cc9f9543781">gul14::SmallVector&lt; ElementT, in_capacity &gt;::resize()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a79e006aadaf59912c25a0a0be4e59571">gul14::SmallVector&lt; ElementT, in_capacity &gt;::SmallVector()</a>.</p>

</div>
</div>
<a id="a1d0e2ee783a74b90f9864cc9f9543781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0e2ee783a74b90f9864cc9f9543781">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of elements in the container. </p>
<p>If the number of elements is decreased, superfluous elements are removed from the end of the container and the capacity is not changed. If the number of elements is increased, default-constructed elements are added at the end of the container and the capacity can grow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>The desired number of elements after resizing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Exception guarantee: If the element default constructor throws while enlarging the vector, the size and content of the container are not changed. However, the capacity might change, and therefore iterators can be invalidated. </dd></dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>.</p>

</div>
</div>
<a id="aa44053f66c8700034cf7905a8ecd868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44053f66c8700034cf7905a8ecd868d">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html#a40b053c83472b979b17dfe047b32fba0">SizeType</a>&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html#a7554e6d5690b059c6573a3205325218d">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of elements in the container. </p>
<p>If the number of elements is decreased, superfluous elements are removed from the end of the container and the capacity is not changed. If the number of elements is increased, copies of the specified element are added at the end of the container and the capacity can grow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>The desired number of elements after resizing </td></tr>
    <tr><td class="paramname">element</td><td>The element to be copied into the new cells when enlarging </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#a634a091f8cb3e1fccb3b02c497d26924">gul14::SmallVector&lt; ElementT, in_capacity &gt;::reserve()</a>.</p>

</div>
</div>
<a id="ab7bc0e29dcd54fca0321322389b2a6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bc0e29dcd54fca0321322389b2a6f7">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the capacity as far as possible while retaining all stored elements. </p>
<p>This might free up some space on the heap, and it invalidates existing iterators. </p>

<p class="reference">References <a class="el" href="classgul14_1_1SmallVector.html#a75111fbfab334a1541aa392fcc59631d">gul14::SmallVector&lt; ElementT, in_capacity &gt;::data()</a>, and <a class="el" href="classgul14_1_1SmallVector.html#aa90eed50ef66c1960f978b240353163c">gul14::SmallVector&lt; ElementT, in_capacity &gt;::inner_capacity()</a>.</p>

</div>
</div>
<a id="a6ac0fa47638f2ad8e70172fa71fcbd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac0fa47638f2ad8e70172fa71fcbd77">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgul14_1_1SmallVector.html">gul14::SmallVector</a>&lt; ElementT, in_capacity &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the contents of this <a class="el" href="classgul14_1_1SmallVector.html" title="A resizable container with contiguous storage that can hold a specified number of elements without al...">SmallVector</a> with those of another one. </p>
<p>If either this or the other vector have internally stored elements (<a class="el" href="classgul14_1_1SmallVector.html#a044c77e200bbb7a5cd53437db5bf9309" title="Return the number of elements that can currently be stored in this vector without having to allocate ...">capacity()</a> &lt;= <a class="el" href="classgul14_1_1SmallVector.html#aa90eed50ef66c1960f978b240353163c" title="Return the number of elements this SmallVector can hold internally without having to allocate storage...">inner_capacity()</a>), this function falls back to element-wise swapping. Otherwise, the heap-allocated buffers are swapped directly. </p>

<p class="reference">Referenced by <a class="el" href="group__SmallVector__h.html#ga4074913afff7c8698358785771ab61db">gul14::swap()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a16efde1ad04ee2e65d30506dfd7aacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16efde1ad04ee2e65d30506dfd7aacc0">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator: Return true if both vectors have a different <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> or at least one different element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if both vectors are equal, true otherwise. </dd></dl>

</div>
</div>
<a id="a556093ed0d8700acfa03836278ee1638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556093ed0d8700acfa03836278ee1638">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementT , size_t in_capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgul14_1_1SmallVector.html">SmallVector</a>&lt; ElementT, in_capacity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator: Return true if both vectors have the same <a class="el" href="classgul14_1_1SmallVector.html#afa8e79bb273d6dc1bb4ecb90405ed957" title="Return the number of elements that are currently stored.">size()</a> and the same elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both vectors are equal, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SmallVector_8h_source.html">SmallVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/>
<address class="footer"><small>
  General Utility Library for C++14 &middot;
  <a href="https://www.desy.de/imprint/index_eng.html">Legal Disclosure</a> &middot;
  <a href="https://www.desy.de/data_privacy_policy/index_eng.html">Privacy Policy</a>
  <!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
</small></address>
</body>
</html>
